Index: src/main/java/be/ac/umons/michelsurin/engine/Action.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package be.ac.umons.michelsurin.engine;\r\n\r\n\r\nimport be.ac.umons.michelsurin.controller.PawnController;\r\nimport be.ac.umons.michelsurin.engine.Game;\r\nimport be.ac.umons.michelsurin.engine.Rules;\r\nimport be.ac.umons.michelsurin.items.Pawn;\r\nimport be.ac.umons.michelsurin.tools.Coord;\r\nimport be.ac.umons.michelsurin.world.Board;\r\nimport be.ac.umons.michelsurin.world.Cell;\r\n\r\nimport java.io.Serializable;\r\nimport java.util.ArrayList;\r\nimport java.util.Random;\r\nimport java.util.Set;\r\n\r\n\r\npublic class Action implements Serializable {\r\n\r\n    public static final long serialVersionUID = -2571765794130091542L;\r\n\r\n    private static Random random = new Random();\r\n\r\n    /**\r\n     * Given a controller, it will, depending on its type (AI, etc)\r\n     * call the correct method that will do an action.\r\n     *\r\n     *\r\n     * @param playerArray\r\n     * @param ctrl the controller\r\n     * @throws IllegalArgumentException is thrown when a controller as an invalid type.\r\n     */\r\n    public static void getAction(PawnController[] playerArray, PawnController ctrl) throws IllegalArgumentException {\r\n        switch (ctrl.getType()) {\r\n            case \"Debilus\" :\r\n            case \"Random\":\r\n            case \"Random1\":\r\n            case \"Random2\":\r\n                debilusActionHandler(playerArray, ctrl);\r\n                break;\r\n            case \"Smarted\" :\r\n            case \"Easy\":\r\n            case \"Easy1\":\r\n            case \"Easy2\":\r\n                System.out.println(\"\\r It's me Smarted!\");\r\n                smartedActionHandler(playerArray, ctrl);\r\n                break;\r\n            case \"Smart\" :\r\n            case \"Hard\":\r\n            case \"Hard1\":\r\n            case \"Hard2\":\r\n                System.out.println(\"\\r It's smart time\");\r\n                smartActionHandler(playerArray, ctrl);\r\n                break;\r\n            case \"DebugDOWN\":\r\n                debugDOWNActionHandler(playerArray, ctrl);\r\n                break;\r\n            case \"DebugUP\":\r\n                debugUPActionHandler(playerArray, ctrl);\r\n                break;\r\n            default:\r\n                throw new IllegalArgumentException(\"the controller has an incorrect type : \" + ctrl.getType());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * a purely debugging AI. It must be initialized at the bottom of the board.\r\n     * It will move forward even if there are walls\r\n     * it will get trough it. Used to test other AI.\r\n     *\r\n     * @param playerArray -\r\n     * @param ctrl -\r\n     */\r\n    private static void debugDOWNActionHandler(PawnController[] playerArray, PawnController ctrl) {\r\n        if (Rules.canMove(ctrl, Game.directions.get(\"DOWN\"))) {\r\n            ctrl.move(Game.directions.get(\"DOWN\"));\r\n        } else {\r\n\r\n        }\r\n\r\n    }\r\n    private static void debugUPActionHandler(PawnController[] playerArray, PawnController ctrl) {\r\n        ctrl.move(Game.directions.get(\"DOWN\"));\r\n    }\r\n\r\n\r\n    /**\r\n     * Method used by \"Smarted\" and \"Smart\" AIs to move following a path given by the pathfinding tool.\r\n     * It takes in account all the rules of quorridor.\r\n     *\r\n     *\r\n     * @param ctrl the PawnController of the AI\r\n     */\r\n    private static void AIAdvancedMove(PawnController ctrl){\r\n        //Tries and move.\r\n        // Almost same as Debilus but follows a path\r\n        Coord direction;\r\n        int randint; //   /!\\    Was a random tool, moved to be a direction indicator\r\n\r\n        ArrayList<Coord> path = Rules.path(ctrl);\r\n        Coord next = path.remove(path.size()-1);\r\n        int deltaY = next.getY() - ctrl.getDependency().getCoord().getY();\r\n        int deltaX = next.getX() - ctrl.getDependency().getCoord().getX();\r\n\r\n        switch (deltaY){\r\n            case 1:\r\n                direction = getDirection(2);\r\n                randint = 2;\r\n                break;\r\n\r\n            case -1:\r\n                direction = getDirection(0);\r\n                randint = 0;\r\n                break;\r\n\r\n            case 0:\r\n                switch (deltaX){\r\n                    case 1:\r\n                        direction = getDirection(3);\r\n                        randint = 3;\r\n                        break;\r\n\r\n                    case -1:\r\n                        direction = getDirection(1);\r\n                        randint = 1;\r\n                        break;\r\n\r\n                    default:\r\n                        throw new IllegalArgumentException(\"deltaX should be 1 or -1.\");\r\n\r\n                }\r\n                break;\r\n\r\n            default:\r\n                throw new IllegalArgumentException(\"deltaY should be 1 or -1.\");\r\n        }\r\n\r\n\r\n\r\n\r\n        Coord forwardCell = Coord.add(ctrl.getDependency().getCoord(), direction);\r\n        //Coordinates of the intended move cell\r\n\r\n        if (ctrl.getBoard().getCell(forwardCell).hasPawn()) {\r\n            //If there is a pawn in \"front\" of itself, tries to bypass it.\r\n\r\n            if (!(Rules.canMove(ctrl, direction, forwardCell)) || ctrl.getBoard().getCell(Coord.add(forwardCell, direction)).hasPawn()) {\r\n                //If it can not go behind, tries to move diagonally\r\n                // (actually it makes moves forward then on the chosen side).\r\n                int tries = 0; //The number of tried moves.\r\n                //Coordinates of the would-be cell it will use to move \"diagonally\".\r\n                int choice = 0; //choose diagonal option (was random, is not anymore).\r\n                Coord directionBis;\r\n\r\n                if (choice == 0) {\r\n                    //Choose the non-clockwise option.\r\n                    int randintBis;\r\n                    //Changes its direction accordingly taking in account the bounds of the array.\r\n                    if (randint == 0)\r\n                        randintBis = 3;\r\n                    else\r\n                        randintBis = randint - 1;\r\n                    directionBis = getDirection(randintBis);\r\n                    if (Rules.canMove(ctrl, directionBis, forwardCell)){\r\n                        ctrl.move(direction); //moves on the same cell as the other pawn\r\n                        ctrl.move(directionBis); //moves to the side not to end in the wall\r\n                    }\r\n                    else {\r\n                        //The chosen option (non-clockwise) was not possible, changes choice.\r\n                        choice = 1;\r\n                    }\r\n                    //CASE IN WHICH THERE IS A PAWN IN FRONT AND A WALL BEHIND IT HALF-HANDLED.\r\n                } else if (choice == 1) {\r\n                    //Choose the clockwise option\r\n                    int randintBis;\r\n                    //Changes its direction accordingly taking in account the bounds of the array.\r\n                    randintBis = randint + 1;\r\n                    if (randintBis == 4)\r\n                        randintBis = 0;\r\n                    directionBis = getDirection(randintBis);\r\n                    if (Rules.canMove(ctrl, directionBis, forwardCell)){\r\n                        ctrl.move(direction); //moves on the same cell as the other pawn\r\n                        ctrl.move(directionBis); //moves to the side not to end in the wall\r\n                    }\r\n                    else {\r\n                        //The chosen option (non-clockwise) was not possible either, tries to move side or back\r\n                        if (Rules.canMove(ctrl,getDirection(randint - 1))) {\r\n                            ctrl.move(getDirection(randint - 1));\r\n                        }\r\n                        else if (Rules.canMove(ctrl, getDirection(randint + 1))){\r\n                            ctrl.move(getDirection(randint + 1));\r\n                        }\r\n                        else {\r\n                            if(randint == 0){\r\n                                randint = 2;\r\n                                ctrl.move(getDirection(randint));\r\n                            }\r\n                            else if (randint == 1){\r\n                                randint = 3;\r\n                                ctrl.move(getDirection(randint));\r\n                            }\r\n                            else if (randint == 2){\r\n                                randint = 0;\r\n                                ctrl.move(getDirection(randint));\r\n                            }\r\n                            else if (randint == 3){\r\n                                randint = 1;\r\n                                ctrl.move(getDirection(randint));\r\n                            }\r\n                        }\r\n                    }\r\n                    //CASE IN WHICH THERE IS A PAWN IN FRONT AND A WALL BEHIND HANDLED.\r\n                }\r\n            } else {\r\n                //If it can go behind.\r\n                ctrl.move(direction); //moves on the same cell as the other pawn\r\n                ctrl.move(direction); //moves on the cell behind the other pawn\r\n            }\r\n        } else {\r\n            //If there is no special condition like a pawn in front of itself\r\n            ctrl.move(direction);\r\n        }\r\n\r\n\r\n    }\r\n\r\n\r\n    /**\r\n     * Wall placement method of \"Smart\" AI.\r\n     * It places walls in priority in the path of the most advanced player (which path is the smallest), beginning by\r\n     * the most next move, and if not possible then following the path (because it's the best way of the target).\r\n     * If can not place any wall on the path of the target, it places the wall which is the best possible to elongate\r\n     * the path of the target.\r\n     * @param playerArray\r\n     * @param ctrl\r\n     */\r\n    private static void smartWallPlacement(PawnController[] playerArray,PawnController ctrl){\r\n        if (ctrl.getNumbWall() > 0) {\r\n            Coord placeCoord;\r\n            Coord placeDir;\r\n\r\n                int ordinate;\r\n                int absciss;\r\n                int intDir;\r\n\r\n                PawnController target = playerArray[0];\r\n                if (ctrl.equals(playerArray[0])){\r\n                    target = playerArray[1];\r\n                }\r\n\r\n                for (PawnController pawnController : playerArray){ //controls the travelled distance of all the players\r\n                    if (travel(pawnController) < travel(target) && !pawnController.equals(ctrl)){ //to see if self is the most advanced.\r\n                        target = pawnController;\r\n                    }\r\n                }\r\n\r\n                ArrayList<Coord> targetPath = Rules.path(target);\r\n                Coord next = targetPath.remove(targetPath.size()-1);\r\n                ordinate = next.getY();\r\n                absciss = next.getX();\r\n\r\n                int deltaY = next.getY() - target.getDependency().getCoord().getY();\r\n                int deltaX = next.getX() - target.getDependency().getCoord().getX();\r\n\r\n                switch (deltaY){\r\n                    case 1:\r\n                    case -1:\r\n                        intDir = 3;\r\n                        break;\r\n                    case 0:\r\n                        switch (deltaX){\r\n                            case 1:\r\n                            case -1:\r\n                                intDir = 0;\r\n                                break;\r\n                            default:\r\n                                throw new IllegalArgumentException(\"deltaX should be 1 or -1.\");\r\n\r\n                        }\r\n                        break;\r\n\r\n                    default:\r\n                        throw new IllegalArgumentException(\"deltaY should be 1 or -1.\");\r\n                }\r\n\r\n\r\n                placeCoord = new Coord(ordinate, absciss);\r\n                placeDir = getDirection(intDir);\r\n\r\n\r\n            if (Rules.canPlaceWall(playerArray, ctrl, placeCoord, placeDir)) {\r\n                ctrl.placeWall(placeCoord, placeDir);\r\n                //Tries to place a wall on the next best move of the most advanced player.\r\n            }\r\n            else {\r\n                if(targetPath.size() > 0) {\r\n                    do {\r\n                        Coord prev = next;\r\n                        Coord newNext = targetPath.remove(targetPath.size() - 1);\r\n\r\n                        ordinate = newNext.getY();\r\n                        absciss = newNext.getX();\r\n                        deltaY = newNext.getY() - prev.getY();\r\n                        deltaX = newNext.getX() - prev.getX();\r\n\r\n                        switch (deltaY) {\r\n                            case 1:\r\n                            case -1:\r\n                                intDir = 3;\r\n                                break;\r\n                            case 0:\r\n                                switch (deltaX) {\r\n                                    case 1:\r\n                                    case -1:\r\n                                        intDir = 0;\r\n                                        break;\r\n                                    default:\r\n                                        throw new IllegalArgumentException(\"deltaX should be 1 or -1.\");\r\n                                }\r\n                                break;\r\n\r\n                            default:\r\n                                throw new IllegalArgumentException(\"deltaY should be 1 or -1.\");\r\n                        }\r\n\r\n\r\n                        placeCoord = new Coord(ordinate, absciss);\r\n                        placeDir = getDirection(intDir);\r\n\r\n                        prev = next;\r\n                        next = newNext;\r\n\r\n                    } while ( !Rules.canPlaceWall(playerArray, ctrl, placeCoord, placeDir) && targetPath.size() > 1);\r\n                }\r\n\r\n                if (Rules.canPlaceWall(playerArray, ctrl, placeCoord, placeDir)) {\r\n                    ctrl.placeWall(placeCoord, placeDir);\r\n                    //Tries to place a wall on the rest of the path (still the best moveset).\r\n                }\r\n                else{ //BAD COMPLEXITY! PLEASE FIX ME! KILL ME! - fixed, I commented\r\n                    AIAdvancedMove(ctrl);\r\n                    /*\r\n                    int pathSize = targetPath.size();\r\n                    Coord maxPathSizeCoord = targetPath.get(targetPath.size() - 1);\r\n                    Coord mathPathSizeDir = getDirection(1);\r\n                    Board tempBoard;\r\n\r\n                    for(Cell[] cellArray : ctrl.getBoard().getCellArray()) {\r\n                        for (Cell cell : cellArray) {\r\n                            tempBoard = new Board(ctrl.getBoard().getSize(), ctrl.getBoard().getPawnCoord());\r\n                            for (Coord[] wall : ctrl.getBoard().getWallList()) {\r\n                                tempBoard.addToWallList(wall);\r\n                            }\r\n                            if (Rules.canPlaceWall(playerArray, ctrl, cell.getCoord(), getDirection(1))){\r\n                                Coord[] testedWall = new Coord[2];\r\n                                testedWall[0] = cell.getCoord();\r\n                                testedWall[1] = Coord.add(cell.getCoord(), getDirection(1));\r\n                                tempBoard.addToWallList(testedWall);\r\n\r\n                                PawnController tempCtrl = new PawnController(target.getType(), (Pawn) target.getDependency(), tempBoard, 66);\r\n                                ArrayList<Coord> newPath = Rules.path(tempCtrl);\r\n                                if (newPath.size() > pathSize){\r\n                                    pathSize = newPath.size();\r\n                                    mathPathSizeDir = getDirection(1);\r\n                                    maxPathSizeCoord = cell.getCoord();\r\n                                }\r\n                            }\r\n\r\n                        }\r\n                    }\r\n                    for(Cell[] cellArray : ctrl.getBoard().getCellArray()) {\r\n                        for (Cell cell : cellArray) {\r\n                            tempBoard = new Board(ctrl.getBoard().getSize(), ctrl.getBoard().getPawnCoord());\r\n                            for (Coord[] wall : ctrl.getBoard().getWallList()) {\r\n                                tempBoard.addToWallList(wall);\r\n                            }\r\n                            if (Rules.canPlaceWall(playerArray, ctrl, cell.getCoord(), getDirection(2))){\r\n                                Coord[] testedWall = new Coord[2];\r\n                                testedWall[0] = cell.getCoord();\r\n                                testedWall[1] = Coord.add(cell.getCoord(), getDirection(2));\r\n                                tempBoard.addToWallList(testedWall);\r\n\r\n                                PawnController tempCtrl = new PawnController(target.getType(), (Pawn) target.getDependency(), tempBoard, 66);\r\n                                ArrayList<Coord> newPath = Rules.path(tempCtrl);\r\n                                if (newPath.size() > pathSize){\r\n                                    pathSize = newPath.size();\r\n                                    mathPathSizeDir = getDirection(2);\r\n                                    maxPathSizeCoord = cell.getCoord();\r\n                                }\r\n                            }\r\n\r\n                        }\r\n                    }\r\n\r\n                    if(Rules.canPlaceWall(playerArray, ctrl, maxPathSizeCoord, mathPathSizeDir)){\r\n                        ctrl.placeWall(maxPathSizeCoord, mathPathSizeDir);\r\n                    }\r\n                    else { //If can not place advantageous wall, better move...\r\n                        AIAdvancedMove(ctrl);\r\n                    } */\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Determinist \"Smart\" AI based on pathfinding to be more efficient than any random resolution algorithm.\r\n     *\r\n     * Smart first determines which player is the closest to victory. If smart is not that player, it will try to move to\r\n     * close the gap if the other player (the closest to victory) has not a path smaller than half the board size.\r\n     * If the other player has a path smaller than half the board size, Smart abandons the \"closing the gap\" strategy\r\n     * and places a wall instead.\r\n     * If Smart is the closest player to victory, it will try place a wall to enlarge the gap with the others.\r\n     * When Smart has no more walls, it moves following the best path (which is the result of the pathfinding), as always.\r\n     *\r\n     * @param playerArray an array of all the players in the game.\r\n     * @param ctrl the controller it has been put in charge of.\r\n     */\r\n    private static void smartActionHandler(PawnController[] playerArray, PawnController ctrl) {\r\n        int selfTravel = travel(ctrl);\r\n        int maxTravel = travel(ctrl);\r\n        PawnController furtherPlayer = ctrl;\r\n        boolean further = true; //true if Smart is the most advanced player in the game at the moment (smaller path).\r\n        for (PawnController pawnController : playerArray) { //controls the travelled distance of all the players\r\n            if (travel(pawnController) < selfTravel) { //to see if Smart is the most advanced (the smallest value of travel)\r\n                further = false;\r\n            }\r\n            if (travel(pawnController) < maxTravel) {\r\n                furtherPlayer = pawnController;\r\n            }\r\n        }\r\n\r\n        if (!further) {\r\n            if (travel(furtherPlayer) < (ctrl.getBoard().getSize() / 2)) {\r\n                if (ctrl.getNumbWall() > 0) {\r\n                    smartWallPlacement(playerArray, ctrl);\r\n                } else {\r\n                    AIAdvancedMove(ctrl);\r\n                }\r\n            } else {\r\n                AIAdvancedMove(ctrl);\r\n            }\r\n\r\n        }\r\n        else {\r\n            if (ctrl.getNumbWall() > 0) {\r\n                smartWallPlacement(playerArray, ctrl);\r\n            } else {\r\n                AIAdvancedMove(ctrl);\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Gives the size of the path of a given player (via PawnController).\r\n     * A smaller path means the player is closer to victory.\r\n     * @param pawnController\r\n     * @return the distance travelled by the pawn\r\n     */\r\n    private static int travel(PawnController pawnController){\r\n        ArrayList<Coord> path = Rules.path(pawnController);\r\n        int travel = path.size();\r\n        return travel;\r\n    }\r\n\r\n\r\n    /**\r\n     * Smarted AI:\r\n     * A slightly less random AI, with a bit of strategy taken in consideration:\r\n     * Smarted follows a path defined by pathfinding tool.\r\n     * Also, we figured out placing a wall between one's start and one's current\r\n     * position (included) leads to better situations, so Smarted place walls accordingly.\r\n     * Nevertheless it should never place a wall between itself and the goal, it moves it instead one cell further right.\r\n     * @param playerArray\r\n     * @param ctrl\r\n     * @throws IllegalArgumentException incorrect delta calculation between two coordinates.\r\n     */\r\n    private static void smartedActionHandler(PawnController[] playerArray, PawnController ctrl) throws IllegalArgumentException {\r\n\r\n        if (ctrl.getSmartedActionChangelog() > 1) { //See above the method.\r\n            ctrl.setSmartedActionChangelog(0); //Just a reinitialisation.\r\n        }\r\n\r\n        if (ctrl.getSmartedActionChangelog() == 0){\r\n            AIAdvancedMove(ctrl);\r\n        }\r\n        else if (ctrl.getSmartedActionChangelog() == 1){ //Tries and place a wall\r\n            if (ctrl.getNumbWall() > 0) {\r\n                Coord placeCoord;\r\n                Coord placeDir;\r\n                int triesWalls = 0;\r\n                do {\r\n                    int ordinate;\r\n                    if (ctrl.getDependency().getCoord().getY() == 0 ||\r\n                            ctrl.getDependency().getCoord().getY() - 1 == 0) {\r\n                        ordinate = random.nextInt(2);\r\n                    }\r\n                    else {\r\n                        Pawn pawn = (Pawn) ctrl.getDependency();\r\n                        if(pawn.getStart().getY() == 0) { //If start at top, place between O and self position\r\n                            ordinate = random.nextInt(ctrl.getDependency().getCoord().getY() - 1);\r\n                        }\r\n                        else { //If start at bottom, place between board size and self position\r\n                            do {\r\n                                ordinate = random.nextInt(ctrl.getBoard().getSize() );\r\n                                }\r\n                            while(ordinate < ctrl.getDependency().getCoord().getY() );\r\n                        }\r\n                    }\r\n                    if ((ordinate == 0) && (ctrl.getDependency().getCoord().getY() != 0)) {\r\n                        ordinate = ctrl.getDependency().getCoord().getY();\r\n                    }\r\n                    else if ((ordinate == 0) && (ctrl.getDependency().getCoord().getY() == 0)){\r\n                        ordinate = 2;\r\n                    }\r\n                    //Does not place a wall further than itself.\r\n                    int absciss = random.nextInt(ctrl.getBoard().getSize() - 1);\r\n\r\n                    int intDir = random.nextInt(2);\r\n                    if (intDir == 1)\r\n                        intDir = 3;\r\n\r\n                    if ((absciss == ctrl.getDependency().getCoord().getX()) && (intDir == 3))\r\n                        absciss += 1;\r\n                    //If the wall is in the way of the goal, displace it.\r\n\r\n                    placeCoord = new Coord(ordinate, absciss);\r\n                    placeDir = getDirection(intDir);\r\n\r\n                    triesWalls++;\r\n                }\r\n                while (!Rules.canPlaceWall(playerArray, ctrl, placeCoord, placeDir) && triesWalls <= 25);\r\n                if (triesWalls <= 25) {\r\n                    ctrl.placeWall(placeCoord, placeDir);\r\n                } else {\r\n                    ctrl.setSmartedActionChangelog(ctrl.getSmartedActionChangelog() + 1);\r\n                    smartedActionHandler(playerArray, ctrl);\r\n                }\r\n\r\n            }\r\n            else {\r\n                ctrl.setSmartedActionChangelog(ctrl.getSmartedActionChangelog() + 1);\r\n                smartedActionHandler(playerArray, ctrl);\r\n            }\r\n\r\n        }\r\n\r\n        ctrl.setSmartedActionChangelog(ctrl.getSmartedActionChangelog() + 1);\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * \"Debilus\" AI:\r\n     * Most basic AI, entirely random due to it's purpose. Is totally intended to be unintelligent and inefficient.\r\n     * Chooses all it's actions and their directions via a random number.\r\n     * @param playerArray\r\n     * @param ctrl\r\n     */\r\n    private static void debilusActionHandler(PawnController[] playerArray, PawnController ctrl) {\r\n\r\n        int action = random.nextInt(2); //Choose randomly between moving and placing a wall.\r\n\r\n        if (action == 0){ //Tries and moves.\r\n            Coord direction;\r\n            int randint;\r\n\r\n            do {\r\n                randint = randomizeDirection();\r\n                direction = getDirection(randint); //Choose a random direction\r\n            }\r\n            while (!(Rules.canMove(ctrl, direction))); //Does so until it can move.\r\n\r\n            Coord forwardCell = Coord.add(ctrl.getDependency().getCoord(), direction);\r\n            //Coordinates of the intended move cell\r\n\r\n            if (ctrl.getBoard().getCell(forwardCell).hasPawn()) {\r\n                //If there is a pawn in \"front\" of itself, tries to bypass it.\r\n\r\n                if (!(Rules.canMove(ctrl, direction, forwardCell)) || ctrl.getBoard().getCell(Coord.add(forwardCell, direction)).hasPawn()) {\r\n                    //If it can not go behind, tries to move diagonally\r\n                    // actually it makes moves forward then on the chosen side).\r\n                    int tries = 0; //The number of tried moves.\r\n                    //Coordinates of the would-be cell it will use to move \"diagonally\".\r\n                    int choice = random.nextInt(1); //choose random diagonal option.\r\n                    Coord directionBis;\r\n\r\n                    if (choice == 0) {\r\n                        //Choose the non-clockwise option.\r\n                        int randintBis;\r\n                        //Changes its direction accordingly taking in account the bounds of the array.\r\n                        if (randint == 0)\r\n                            randintBis = 3;\r\n                        else\r\n                            randintBis = randint - 1;\r\n                        directionBis = getDirection(randintBis);\r\n                        if (Rules.canMove(ctrl, directionBis, forwardCell)){\r\n                            ctrl.move(direction); //moves on the same cell as the other pawn\r\n                            ctrl.move(directionBis); //moves to the side not to end in the wall\r\n                        } else {\r\n                            if (tries == 0) {\r\n                                //The chosen option (non-clockwise) was not possible, changes choice.\r\n                                choice = 1;\r\n                                tries += 1;\r\n                            } else action = 1;\r\n                        }\r\n                        //CASE IN WHICH THERE IS A PAWN IN FRONT AND A WALL BEHIND IT HALF-HANDLED.\r\n                    } else if (choice == 1) {\r\n                        //Choose the clockwise option\r\n                        int randintBis;\r\n                        //Changes its direction accordingly taking in account the bounds of the array.\r\n                        randintBis = randint + 1;\r\n                        if (randintBis == 4)\r\n                            randintBis = 0;\r\n                        directionBis = getDirection(randintBis);\r\n                        if (Rules.canMove(ctrl, directionBis, forwardCell)){\r\n                            ctrl.move(direction); //moves on the same cell as the other pawn\r\n                            ctrl.move(directionBis); //moves to the side not to end in the wall\r\n                        } else {\r\n                            if (tries == 0) {\r\n                                //The chosen option (non-clockwise) was not possible, changes choice.\r\n                                choice = 0;\r\n                                tries += 1;\r\n                            } else action = 1;\r\n                        }\r\n                        //CASE IN WHICH THERE IS A PAWN IN FRONT AND A WALL BEHIND HANDLED.\r\n                    }\r\n                } else {\r\n                    //If it can go behind.\r\n                    ctrl.move(direction); //moves on the same cell as the other pawn\r\n                    ctrl.move(direction); //moves on the cell behind the other pawn\r\n                }\r\n            } else {\r\n                //If there is no special condition like a pawn in front of itself\r\n                ctrl.move(direction);\r\n            }\r\n\r\n\r\n        } else if (action == 1){ //Tries and place a wall\r\n\r\n            if (ctrl.getNumbWall() > 0) {\r\n                Coord placeCoord;\r\n                Coord placeDir;\r\n                int triesWalls = 0;\r\n                do {\r\n                    int ordinate = random.nextInt(ctrl.getBoard().getSize() - 1);\r\n                    if (ordinate == 0){ //We want ordinates 1 to 8\r\n                        ordinate = ctrl.getBoard().getSize()-1;\r\n                    }\r\n\r\n                    int absciss = random.nextInt(ctrl.getBoard().getSize() - 2);\r\n                    //We want abcisses 0 to 7\r\n                    placeCoord = new Coord(ordinate, absciss);\r\n\r\n                    int intDir = random.nextInt(2);\r\n                    if (intDir == 1)\r\n                        intDir = 3;\r\n                    placeDir = getDirection(intDir);\r\n                    triesWalls++;\r\n                }\r\n                while ( !Rules.canPlaceWall(playerArray, ctrl, placeCoord, placeDir) && triesWalls <= 25);\r\n                if (triesWalls <= 25) {\r\n                    ctrl.placeWall(placeCoord, placeDir);\r\n                } else {\r\n                    debilusActionHandler(playerArray, ctrl);\r\n                }\r\n            } else {\r\n                debilusActionHandler(playerArray, ctrl);\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n\r\n    /**\r\n     * Use a integer between 0 and 3 (both included) to permit a random choice via a random integer.\r\n     * @param i the integer mentioned above.\r\n     * @return a direction from Game.direction\r\n     * @throws IllegalArgumentException in case the method does not receive an integer between 0 and 3 both included.\r\n     */\r\n    protected static Coord getDirection(int i) throws IllegalArgumentException {\r\n        switch (i){\r\n            case 0:\r\n                return Game.directions.get(\"UP\");\r\n\r\n            case 1:\r\n                return Game.directions.get(\"LEFT\");\r\n\r\n            case 2:\r\n                return Game.directions.get(\"DOWN\");\r\n\r\n            case 3:\r\n                return Game.directions.get(\"RIGHT\");\r\n\r\n            default:\r\n                throw new IllegalArgumentException(\"Did not receive 0, 1, 2 or 3 as integer.\");\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Use the Random module to generate a random integer (see usage in getDirection() method).\r\n     * @return an integer between 0 and 3 both included.\r\n     */\r\n    protected static int randomizeDirection(){\r\n        float randfloat = random.nextInt(4);\r\n        return Math.round(randfloat);\r\n\r\n    }\r\n\r\n    /**\r\n     * given a player (PawnController). It will check all the cell around its position and return an array\r\n     * containing all the cells where the player can go from it's position.\r\n     * It takes in consideration walls and pawns\r\n     *\r\n     * @param ctrl the player/controller for whom we are looking for reachable cell.\r\n     * @return an array with all the cell reachable from the player's position.\r\n     */\r\n    public static Coord[] whereCanIGo(PawnController ctrl) {\r\n        ArrayList<Coord> list = new ArrayList<Coord>();\r\n        Board board = ctrl.getBoard();\r\n        Coord ctrlCoord = ctrl.getDependency().getCoord();\r\n        Set<String> keys = Game.directions.keySet();\r\n        for (String key : keys) {\r\n            Coord dir = Game.directions.get(key);\r\n            if (Rules.canMove(ctrl, Game.directions.get(key)) && !board.getCell(Coord.add(ctrlCoord, dir)).hasPawn()) {\r\n                //no pawn, no wall, free to go\r\n                list.add(Coord.add(ctrlCoord, dir));\r\n            } else if (Rules.canMove(ctrl, Game.directions.get(key)) && board.getCell(Coord.add(ctrlCoord, dir)).hasPawn()) {\r\n                //there is a pawn, we need to check if there is a wall or a pawn behind it\r\n                Coord encounteredPawnCoord = Coord.add(ctrlCoord, dir);\r\n                Coord behindCoord = Coord.add(encounteredPawnCoord, dir);\r\n                if (Rules.canMove(ctrl, dir, encounteredPawnCoord) && !board.getCell(behindCoord).hasPawn()) {\r\n                    //no pawn, no wall, free to go !\r\n                    list.add(behindCoord);\r\n                } else if (!Rules.canMove(ctrl, dir, encounteredPawnCoord) || board.getCell(Coord.add(encounteredPawnCoord, dir)).hasPawn() ){\r\n                    //there is a wall or a pawn behind the encountered pawn. We need to check on\r\n                    //encountered pawn's sides.\r\n                    //there is 2 sides direction, if the current dir is UP or DOWN --> side dir will be LEFT and RIGHT\r\n                    //if the current dir is LEFT or RIGHT --> side dir will be UP and DOWN\r\n                    if (dir.compareTo(Game.directions.get(\"UP\")) == 0 || dir.compareTo(Game.directions.get(\"DOWN\")) == 0) {\r\n                        //side dir are LEFT and RIGHT\r\n                        if (Rules.canMove(ctrl, Game.directions.get(\"LEFT\"), encounteredPawnCoord)\r\n                                && !board.getCell(Coord.add(encounteredPawnCoord, Game.directions.get(\"LEFT\"))).hasPawn() ) {\r\n                            list.add(Coord.add(encounteredPawnCoord, Game.directions.get(\"LEFT\")));\r\n                        }\r\n                        if (Rules.canMove(ctrl, Game.directions.get(\"RIGHT\"), encounteredPawnCoord)\r\n                                && !board.getCell(Coord.add(encounteredPawnCoord, Game.directions.get(\"RIGHT\"))).hasPawn()) {\r\n                            list.add(Coord.add(encounteredPawnCoord, Game.directions.get(\"RIGHT\")));\r\n                        }\r\n                    } else {\r\n                        //side dir are UP and DOWN\r\n                        if (Rules.canMove(ctrl, Game.directions.get(\"UP\"), encounteredPawnCoord)\r\n                                && !board.getCell(Coord.add(encounteredPawnCoord, Game.directions.get(\"UP\"))).hasPawn()) {\r\n                            list.add(Coord.add(encounteredPawnCoord, Game.directions.get(\"UP\")));\r\n                        }\r\n                        if (Rules.canMove(ctrl, Game.directions.get(\"DOWN\"), encounteredPawnCoord)\r\n                                && !board.getCell(Coord.add(encounteredPawnCoord, Game.directions.get(\"DOWN\"))).hasPawn()) {\r\n                            list.add(Coord.add(encounteredPawnCoord, Game.directions.get(\"DOWN\")));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        Coord[] array = list.toArray(Coord[]::new); //convert to an array to make sure it won't change\r\n        return  array;\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/be/ac/umons/michelsurin/engine/Action.java	(revision 9d94c97cc588838438ab780d8d62f9f102db42b4)
+++ src/main/java/be/ac/umons/michelsurin/engine/Action.java	(date 1589291531598)
@@ -152,6 +152,7 @@
                 int choice = 0; //choose diagonal option (was random, is not anymore).
                 Coord directionBis;
 
+
                 if (choice == 0) {
                     //Choose the non-clockwise option.
                     int randintBis;
@@ -161,7 +162,7 @@
                     else
                         randintBis = randint - 1;
                     directionBis = getDirection(randintBis);
-                    if (Rules.canMove(ctrl, directionBis, forwardCell)){
+                    if (Rules.canMove(ctrl, directionBis, forwardCell) && !ctrl.getBoard().getCell(Coord.add(forwardCell, direction)).hasPawn()){
                         ctrl.move(direction); //moves on the same cell as the other pawn
                         ctrl.move(directionBis); //moves to the side not to end in the wall
                     }
@@ -178,36 +179,84 @@
                     if (randintBis == 4)
                         randintBis = 0;
                     directionBis = getDirection(randintBis);
-                    if (Rules.canMove(ctrl, directionBis, forwardCell)){
+                    if (Rules.canMove(ctrl, directionBis, forwardCell) && !ctrl.getBoard().getCell(Coord.add(forwardCell, direction)).hasPawn()){
                         ctrl.move(direction); //moves on the same cell as the other pawn
                         ctrl.move(directionBis); //moves to the side not to end in the wall
                     }
                     else {
+                        Coord currentCell = ctrl.getDependency().getCoord();
                         //The chosen option (non-clockwise) was not possible either, tries to move side or back
-                        if (Rules.canMove(ctrl,getDirection(randint - 1))) {
+                        if (Rules.canMove(ctrl,getDirection(randint - 1)) && !ctrl.getBoard().getCell(Coord.add(currentCell, getDirection(randint - 1))).hasPawn()) {
                             ctrl.move(getDirection(randint - 1));
                         }
-                        else if (Rules.canMove(ctrl, getDirection(randint + 1))){
-                            ctrl.move(getDirection(randint + 1));
-                        }
-                        else {
-                            if(randint == 0){
-                                randint = 2;
-                                ctrl.move(getDirection(randint));
-                            }
-                            else if (randint == 1){
-                                randint = 3;
-                                ctrl.move(getDirection(randint));
-                            }
-                            else if (randint == 2){
-                                randint = 0;
-                                ctrl.move(getDirection(randint));
-                            }
-                            else if (randint == 3){
-                                randint = 1;
-                                ctrl.move(getDirection(randint));
+                        else if (Rules.canMove(ctrl, getDirection(randint + 1)) && !ctrl.getBoard().getCell(Coord.add(currentCell, getDirection(randint + 1))).hasPawn()){
+                            ctrl.move(getDirection(randint + 1));
+                        }
+                        else {
+                            if(randint == 0 && Rules.canMove(ctrl, getDirection(2)) && !ctrl.getBoard().getCell(Coord.add(currentCell, getDirection(2))).hasPawn()){
+                                randint = 2;
+                                ctrl.move(getDirection(randint));
+                            }
+                            else if (randint == 1 && Rules.canMove(ctrl, getDirection(3)) && !ctrl.getBoard().getCell(Coord.add(currentCell, getDirection(3))).hasPawn()){
+                                randint = 3;
+                                ctrl.move(getDirection(randint));
+                            }
+                            else if (randint == 2 && Rules.canMove(ctrl, getDirection(0)) && !ctrl.getBoard().getCell(Coord.add(currentCell, getDirection(0))).hasPawn()){
+                                randint = 0;
+                                ctrl.move(getDirection(randint));
+                            }
+                            else if (randint == 3 && Rules.canMove(ctrl, getDirection(1)) && !ctrl.getBoard().getCell(Coord.add(currentCell, getDirection(1))).hasPawn()){
+                                randint = 1;
+                                ctrl.move(getDirection(randint));
+                            }
+                            else {
+                                while (ctrl.getBoard().getCell(forwardCell).hasPawn()){
+                                    if(ctrl.getBoard().getCell(Coord.add(forwardCell, direction)).hasPawn()){
+                                        forwardCell = Coord.add(forwardCell, direction);
+                                    }
+                                    else if (!Rules.canMove(ctrl, direction, forwardCell)){
+                                        switch (randint){
+                                            case 0:
+                                                randint = 2;
+                                                break;
+                                            case 1:
+                                                randint = 3;
+                                                break;
+                                            case 2:
+                                                randint = 0;
+                                                break;
+                                            case 3:
+                                                randint = 1;
+                                                break;
+                                            default:
+                                                break;
+                                        }
+                                    }
+                                    if (Rules.canMove(ctrl,getDirection(randint - 1)) && !ctrl.getBoard().getCell(Coord.add(currentCell, getDirection(randint - 1))).hasPawn()) {
+                                        ctrl.move(getDirection(randint - 1));
+                                    }
+                                    else if (Rules.canMove(ctrl, getDirection(randint + 1)) && !ctrl.getBoard().getCell(Coord.add(currentCell, getDirection(randint + 1))).hasPawn()){
+                                        ctrl.move(getDirection(randint + 1));
+                                    }
+                                    else {
+                                        if (randint == 0 && Rules.canMove(ctrl, getDirection(2)) && !ctrl.getBoard().getCell(Coord.add(currentCell, getDirection(2))).hasPawn()) {
+                                            randint = 2;
+                                            ctrl.move(getDirection(randint));
+                                        } else if (randint == 1 && Rules.canMove(ctrl, getDirection(3)) && !ctrl.getBoard().getCell(Coord.add(currentCell, getDirection(3))).hasPawn()) {
+                                            randint = 3;
+                                            ctrl.move(getDirection(randint));
+                                        } else if (randint == 2 && Rules.canMove(ctrl, getDirection(0)) && !ctrl.getBoard().getCell(Coord.add(currentCell, getDirection(0))).hasPawn()) {
+                                            randint = 0;
+                                            ctrl.move(getDirection(randint));
+                                        } else if (randint == 3 && Rules.canMove(ctrl, getDirection(1)) && !ctrl.getBoard().getCell(Coord.add(currentCell, getDirection(1))).hasPawn()) {
+                                            randint = 1;
+                                            ctrl.move(getDirection(randint));
+                                        }
+                                    }
+                                }
                             }
                         }
+
                     }
                     //CASE IN WHICH THERE IS A PAWN IN FRONT AND A WALL BEHIND HANDLED.
                 }
@@ -565,6 +614,7 @@
     private static void debilusActionHandler(PawnController[] playerArray, PawnController ctrl) {
 
         int action = random.nextInt(2); //Choose randomly between moving and placing a wall.
+        Coord currentCell = ctrl.getDependency().getCoord();
 
         if (action == 0){ //Tries and moves.
             Coord direction;
@@ -599,7 +649,7 @@
                         else
                             randintBis = randint - 1;
                         directionBis = getDirection(randintBis);
-                        if (Rules.canMove(ctrl, directionBis, forwardCell)){
+                        if (Rules.canMove(ctrl, directionBis, forwardCell) && !ctrl.getBoard().getCell(Coord.add(currentCell, getDirection(1))).hasPawn()){
                             ctrl.move(direction); //moves on the same cell as the other pawn
                             ctrl.move(directionBis); //moves to the side not to end in the wall
                         } else {
@@ -618,16 +668,94 @@
                         if (randintBis == 4)
                             randintBis = 0;
                         directionBis = getDirection(randintBis);
-                        if (Rules.canMove(ctrl, directionBis, forwardCell)){
+                        if (Rules.canMove(ctrl, directionBis, forwardCell) && !ctrl.getBoard().getCell(Coord.add(currentCell, getDirection(1))).hasPawn()){
                             ctrl.move(direction); //moves on the same cell as the other pawn
                             ctrl.move(directionBis); //moves to the side not to end in the wall
-                        } else {
-                            if (tries == 0) {
-                                //The chosen option (non-clockwise) was not possible, changes choice.
-                                choice = 0;
-                                tries += 1;
-                            } else action = 1;
+                        }
+
+                        else {
+
+                            //The chosen option (non-clockwise) was not possible either, tries to move side or back
+                            if (Rules.canMove(ctrl,getDirection(randint - 1)) && !ctrl.getBoard().getCell(Coord.add(currentCell, getDirection(randint - 1))).hasPawn()) {
+                                ctrl.move(getDirection(randint - 1));
+                            }
+                            else if (Rules.canMove(ctrl, getDirection(randint + 1)) && !ctrl.getBoard().getCell(Coord.add(currentCell, getDirection(randint + 1))).hasPawn()){
+                                ctrl.move(getDirection(randint + 1));
+                            }
+                            else {
+                                if(randint == 0 && Rules.canMove(ctrl, getDirection(2)) && !ctrl.getBoard().getCell(Coord.add(currentCell, getDirection(2))).hasPawn()){
+                                    randint = 2;
+                                    ctrl.move(getDirection(randint));
+                                }
+                                else if (randint == 1 && Rules.canMove(ctrl, getDirection(3)) && !ctrl.getBoard().getCell(Coord.add(currentCell, getDirection(3))).hasPawn()){
+                                    randint = 3;
+                                    ctrl.move(getDirection(randint));
+                                }
+                                else if (randint == 2 && Rules.canMove(ctrl, getDirection(0)) && !ctrl.getBoard().getCell(Coord.add(currentCell, getDirection(0))).hasPawn()){
+                                    randint = 0;
+                                    ctrl.move(getDirection(randint));
+                                }
+                                else if (randint == 3 && Rules.canMove(ctrl, getDirection(1)) && !ctrl.getBoard().getCell(Coord.add(currentCell, getDirection(1))).hasPawn()){
+                                    randint = 1;
+                                    ctrl.move(getDirection(randint));
+                                }
+                                else {
+                                    while (ctrl.getBoard().getCell(forwardCell).hasPawn()){
+                                        if(ctrl.getBoard().getCell(Coord.add(forwardCell, direction)).hasPawn()){
+                                            forwardCell = Coord.add(forwardCell, direction);
+                                        }
+                                        else if (!Rules.canMove(ctrl, direction, forwardCell)){
+                                            switch (randint){
+                                                case 0:
+                                                    randint = 2;
+                                                    break;
+                                                case 1:
+                                                    randint = 3;
+                                                    break;
+                                                case 2:
+                                                    randint = 0;
+                                                    break;
+                                                case 3:
+                                                    randint = 1;
+                                                    break;
+                                                default:
+                                                    break;
+                                            }
+                                        }
+                                        if (Rules.canMove(ctrl,getDirection(randint - 1)) && !ctrl.getBoard().getCell(Coord.add(currentCell, getDirection(randint - 1))).hasPawn()) {
+                                            ctrl.move(getDirection(randint - 1));
+                                        }
+                                        else if (Rules.canMove(ctrl, getDirection(randint + 1)) && !ctrl.getBoard().getCell(Coord.add(currentCell, getDirection(randint + 1))).hasPawn()){
+                                            ctrl.move(getDirection(randint + 1));
+                                        }
+                                        else {
+                                            if (randint == 0 && Rules.canMove(ctrl, getDirection(2)) && !ctrl.getBoard().getCell(Coord.add(currentCell, getDirection(2))).hasPawn()) {
+                                                randint = 2;
+                                                ctrl.move(getDirection(randint));
+                                            } else if (randint == 1 && Rules.canMove(ctrl, getDirection(3)) && !ctrl.getBoard().getCell(Coord.add(currentCell, getDirection(3))).hasPawn()) {
+                                                randint = 3;
+                                                ctrl.move(getDirection(randint));
+                                            } else if (randint == 2 && Rules.canMove(ctrl, getDirection(0)) && !ctrl.getBoard().getCell(Coord.add(currentCell, getDirection(0))).hasPawn()) {
+                                                randint = 0;
+                                                ctrl.move(getDirection(randint));
+                                            } else if (randint == 3 && Rules.canMove(ctrl, getDirection(1)) && !ctrl.getBoard().getCell(Coord.add(currentCell, getDirection(1))).hasPawn()) {
+                                                randint = 1;
+                                                ctrl.move(getDirection(randint));
+                                            }
+                                            else {
+                                                if (tries == 0) {
+                                                    //The chosen option (non-clockwise) was not possible, changes choice.
+                                                    choice = 0;
+                                                    tries += 1;
+                                                } else action = 1;
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+
                         }
+
                         //CASE IN WHICH THERE IS A PAWN IN FRONT AND A WALL BEHIND HANDLED.
                     }
                 } else {
@@ -684,6 +812,9 @@
      * @throws IllegalArgumentException in case the method does not receive an integer between 0 and 3 both included.
      */
     protected static Coord getDirection(int i) throws IllegalArgumentException {
+        if (i > 3){
+            i = i%3;
+        }
         switch (i){
             case 0:
                 return Game.directions.get("UP");
Index: .idea/shelf/Uncommitted_changes_before_Update_at_05-05-20_11_31_[Default_Changelist]/shelved.patch
===================================================================
--- .idea/shelf/Uncommitted_changes_before_Update_at_05-05-20_11_31_[Default_Changelist]/shelved.patch	(revision 9d94c97cc588838438ab780d8d62f9f102db42b4)
+++ .idea/shelf/Uncommitted_changes_before_Update_at_05-05-20_11_31_[Default_Changelist]/shelved.patch	(revision 9d94c97cc588838438ab780d8d62f9f102db42b4)
@@ -1,149 +0,0 @@
-Index: src/main/java/be/ac/umons/michelsurin/engine/SaverLoader.java
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>package be.ac.umons.michelsurin.engine;\r\n\r\nimport java.io.*;\r\nimport java.nio.file.Path;\r\nimport java.nio.file.Paths;\r\n\r\n/**\r\n * Save and load games, has path in memory\r\n */\r\npublic class SaverLoader {\r\n\r\n    private Path path = Paths.get(\"./src/main/java/be/ac/umons/michelsurin/engine/Save.txt\");\r\n    private File file = path.toFile();\r\n\r\n\r\n    public void save(Game game) throws IOException {\r\n        File selectedFile = file;\r\n        if (selectedFile != null) {\r\n            FileOutputStream file = new FileOutputStream(selectedFile);\r\n            BufferedOutputStream buf = new BufferedOutputStream(file);\r\n            ObjectOutputStream stream = new ObjectOutputStream(buf);\r\n            stream.writeObject(game);\r\n            stream.close();  // Thanks Mr. Pierre HAUWEELE! :D\r\n\r\n\r\n        }\r\n        else {\r\n            throw new FileNotFoundException(\"File does not exist!\");\r\n        }\r\n    }\r\n\r\n    public Game load() throws IOException, ClassNotFoundException {\r\n        File selectedFile = file;\r\n        Game game;\r\n        if (selectedFile != null) {\r\n            FileInputStream file = new FileInputStream(selectedFile);\r\n            BufferedInputStream buf = new BufferedInputStream(file);\r\n            ObjectInputStream stream = new ObjectInputStream(buf);\r\n\r\n            game = (Game) stream.readObject();\r\n            stream.close();\r\n            return game;\r\n\r\n        }\r\n        else {\r\n            throw new FileNotFoundException(\"File does not exist!\");\r\n        }\r\n    }\r\n}\r\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
---- src/main/java/be/ac/umons/michelsurin/engine/SaverLoader.java	(revision 0ae0412dd83170111fc3aefe35706d32039316fe)
-+++ src/main/java/be/ac/umons/michelsurin/engine/SaverLoader.java	(date 1588670541452)
-@@ -9,11 +9,11 @@
-  */
- public class SaverLoader {
- 
--    private Path path = Paths.get("./src/main/java/be/ac/umons/michelsurin/engine/Save.txt");
--    private File file = path.toFile();
-+    private static Path path = Paths.get("./src/main/java/be/ac/umons/michelsurin/engine/Save.txt");
-+    private static File file = path.toFile();
- 
- 
--    public void save(Game game) throws IOException {
-+    public static void save(Game game) throws IOException {
-         File selectedFile = file;
-         if (selectedFile != null) {
-             FileOutputStream file = new FileOutputStream(selectedFile);
-@@ -29,7 +29,7 @@
-         }
-     }
- 
--    public Game load() throws IOException, ClassNotFoundException {
-+    public static Game load() throws IOException, ClassNotFoundException {
-         File selectedFile = file;
-         Game game;
-         if (selectedFile != null) {
-Index: src/main/java/be/ac/umons/michelsurin/gui/Menu.java
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>package be.ac.umons.michelsurin.gui;\r\n\r\nimport be.ac.umons.michelsurin.engine.Game;\r\nimport be.ac.umons.michelsurin.engine.SaverLoader;\r\nimport javafx.application.Application;\r\nimport javafx.event.ActionEvent;\r\nimport javafx.event.EventHandler;\r\nimport javafx.geometry.Pos;\r\nimport javafx.scene.Scene;\r\nimport javafx.scene.control.Button;\r\nimport javafx.scene.control.ChoiceBox;\r\nimport javafx.scene.control.Label;\r\nimport javafx.scene.control.Separator;\r\nimport javafx.scene.layout.Background;\r\nimport javafx.scene.layout.VBox;\r\nimport javafx.scene.paint.Color;\r\nimport javafx.stage.Stage;\r\n\r\nimport java.io.IOException;\r\n\r\npublic class Menu extends Application {\r\n\r\n\r\n    private Scene scene;\r\n    private Button launchButton;\r\n    private Button closeButton;\r\n    private Stage window;\r\n    private VBox layout;\r\n\r\n    /**\r\n     * Load a game.\r\n     */\r\n    private Button loadButton;\r\n\r\n    /**\r\n     * Save and load games.\r\n     */\r\n    private SaverLoader saverLoader;\r\n\r\n    private ChoiceBox<String> playerNumber;\r\n    private ChoiceBox<String> firstAIDifficultyMenu;\r\n    private ChoiceBox<String> secondAIDifficultyMenu;\r\n    private ChoiceBox<String> thirdAIDifficultyMenu;\r\n    private ChoiceBox<String> fourthAIDifficultyMenu;\r\n    private ChoiceBox<String> wallOptions;\r\n\r\n    private int playerNumberInt;\r\n    private String firstPlayerType;\r\n    private String secondPlayerType;\r\n    private String thirdPlayerType;\r\n    private String fourthPlayerType;\r\n    private int wallNumber;\r\n\r\n    /**\r\n     *\r\n     * @param args\r\n     */\r\n    public static void main(String[] args) {\r\n        launch(args);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param primaryStage\r\n     */\r\n    @Override\r\n    public void start(Stage primaryStage) {\r\n        window = primaryStage;\r\n        window.setOnCloseRequest(e -> {\r\n            e.consume(); //Say to Java : \"Hey, we're handling this ourselves.\"\r\n            closeProgram();\r\n        });\r\n\r\n        closeButton = new Button(\"Close the game\");\r\n        closeButton.setOnAction(e -> closeProgram());\r\n\r\n        window.setTitle(\"Main Menu\");\r\n        window.setMinWidth(600);\r\n        window.setMinHeight(600);\r\n\r\n        layout = new VBox();\r\n        layout.setAlignment(Pos.CENTER);\r\n        layout.setSpacing(20);\r\n        layout.setBackground(Background.EMPTY);\r\n\r\n\r\n        launchButton = new Button(\"Launch game!\");\r\n        launchButton.setOnAction(e -> launchGame(window));\r\n        layout.getChildren().add(launchButton);\r\n\r\n        loadButton = new Button(\"Load Game\");\r\n        loadButton.setOnAction(new EventHandler<ActionEvent>() {\r\n            @Override\r\n            public void handle(ActionEvent event) {\r\n                try {\r\n                    Game game = saverLoader.load();\r\n                    GameUI gameUI = new GameUI(window, scene, game);\r\n                } catch (IOException | ClassNotFoundException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        });\r\n        layout.getChildren().add(loadButton);\r\n\r\n        layout.getChildren().add(closeButton);\r\n\r\n        Separator separator = new Separator();\r\n        layout.getChildren().add(separator);\r\n\r\n\r\n        Label settings = new Label(\"Settings:\");\r\n        layout.getChildren().add(settings);\r\n\r\n        //Following lines will set difficulty menus for AI. Listeners will follow in real time selection changes.\r\n        firstAIDifficultyMenu = new ChoiceBox<>();\r\n        firstAIDifficultyMenu.getItems().addAll(\"Human\", \"Random AI\", \"Easy\", \"Harder\");\r\n        firstAIDifficultyMenu.setValue(\"Human\");\r\n        firstPlayerType = getPlayerType(firstAIDifficultyMenu.getValue());\r\n        firstAIDifficultyMenu.getSelectionModel().selectedItemProperty().addListener( (v, oldValue, newValue) -> {\r\n            firstPlayerType = getPlayerType(newValue);\r\n        });\r\n\r\n        secondAIDifficultyMenu = new ChoiceBox<>();\r\n        secondAIDifficultyMenu.getItems().addAll(\"Human\", \"Random AI\", \"Easy\", \"Harder\");\r\n        secondAIDifficultyMenu.setValue(\"Easy\");\r\n        secondPlayerType = getPlayerType(secondAIDifficultyMenu.getValue());\r\n        secondAIDifficultyMenu.getSelectionModel().selectedItemProperty().addListener( (v, oldValue, newValue) -> {\r\n            secondPlayerType = getPlayerType(newValue);\r\n        });\r\n\r\n        thirdAIDifficultyMenu = new ChoiceBox<>();\r\n        thirdAIDifficultyMenu.getItems().addAll(\"Human\", \"Random AI\", \"Easy\", \"Harder\");\r\n        thirdAIDifficultyMenu.setValue(\"Easy\");\r\n        thirdPlayerType = getPlayerType(thirdAIDifficultyMenu.getValue());\r\n        thirdAIDifficultyMenu.getSelectionModel().selectedItemProperty().addListener( (v, oldValue, newValue) -> {\r\n            thirdPlayerType = getPlayerType(newValue);\r\n        });\r\n\r\n        fourthAIDifficultyMenu = new ChoiceBox<>();\r\n        fourthAIDifficultyMenu.getItems().addAll(\"Human\", \"Random AI\", \"Easy\", \"Harder\");\r\n        fourthAIDifficultyMenu.setValue(\"Easy\");\r\n        fourthPlayerType = getPlayerType(fourthAIDifficultyMenu.getValue());\r\n        fourthAIDifficultyMenu.getSelectionModel().selectedItemProperty().addListener( (v, oldValue, newValue) -> {\r\n            fourthPlayerType  = getPlayerType(newValue);\r\n        });\r\n\r\n        Label walls = new Label(\"Walls:\");\r\n        layout.getChildren().add(walls);\r\n        //Number of walls menu:\r\n        wallOptions = new ChoiceBox<>();\r\n        wallOptions.getItems().addAll(\"5 walls\", \"10 walls\");\r\n        wallOptions.setValue(\"10 walls\");\r\n        wallNumber = 10;\r\n        wallOptions.getSelectionModel().selectedItemProperty().addListener( (v, oldValue, newValue) -> {\r\n            switch (newValue){\r\n                case \"5 walls\":\r\n                    wallNumber = 5;\r\n                    break;\r\n                case \"10 walls\":\r\n                    wallNumber =10;\r\n                    break;\r\n                default:\r\n                    throw new IllegalArgumentException(\"Uh oh... something went wrong with wall numbers in the menu...\");\r\n            }\r\n        });\r\n        layout.getChildren().add(wallOptions);\r\n\r\n\r\n        Label players = new Label(\"Players:\");\r\n        layout.getChildren().add(players);\r\n        //Player number menus, will define which difficulty options are enabled.\r\n        playerNumber = new ChoiceBox<>();\r\n        playerNumber.getItems().addAll( \"2 Players\",\r\n                \"4 Players\");\r\n        playerNumber.setValue(\"2 Players\");\r\n        playerNumberInt = 2;\r\n        layout.getChildren().add(playerNumber);\r\n        Label difficulty = new Label(\"AI difficulty:\");\r\n        layout.getChildren().add(difficulty);\r\n        //default state\r\n        layout.getChildren().remove(firstAIDifficultyMenu);\r\n        layout.getChildren().remove(secondAIDifficultyMenu);\r\n        layout.getChildren().remove(thirdAIDifficultyMenu);\r\n        layout.getChildren().remove(fourthAIDifficultyMenu);\r\n        layout.getChildren().addAll(firstAIDifficultyMenu, secondAIDifficultyMenu);\r\n        playerNumber.getSelectionModel().selectedItemProperty().addListener( (v, oldValue, newValue) -> {\r\n            if (newValue.equals(\"2 Players\")){\r\n                playerNumberInt = 2;\r\n                layout.getChildren().remove(firstAIDifficultyMenu);\r\n                layout.getChildren().remove(secondAIDifficultyMenu);\r\n                layout.getChildren().remove(thirdAIDifficultyMenu);\r\n                layout.getChildren().remove(fourthAIDifficultyMenu);\r\n                layout.getChildren().addAll(firstAIDifficultyMenu, secondAIDifficultyMenu);\r\n            }\r\n            else if (newValue.equals(\"4 Players\")){\r\n                playerNumberInt = 4;\r\n                layout.getChildren().remove(firstAIDifficultyMenu);\r\n                layout.getChildren().remove(secondAIDifficultyMenu);\r\n                layout.getChildren().addAll(firstAIDifficultyMenu, secondAIDifficultyMenu, thirdAIDifficultyMenu, fourthAIDifficultyMenu);\r\n            }\r\n        });\r\n        layout.setMinSize(600, 600);\r\n        scene = new Scene(layout);\r\n        scene.getStylesheets().add(\"Viper.css\");\r\n        window.setScene(scene);\r\n        window.show();\r\n\r\n\r\n    }\r\n\r\n    private void closeProgram(){\r\n        boolean answer = ConfirmBox.Display(\"Quit confirmation\",\r\n                \"  Are you sure you want to quit? \\nDon't forget to save your games!\");\r\n        if (answer) {\r\n            window.close();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert string to valid player type.\r\n     * @param string\r\n     * @return\r\n     * @throws IllegalArgumentException\r\n     */\r\n    private String getPlayerType(String string) throws IllegalArgumentException{\r\n        switch (string) {\r\n            case \"Human\":\r\n                return string;\r\n            case \"Random AI\":\r\n                return \"Debilus\";\r\n            case \"Easy\":\r\n                return \"Smarted\";\r\n            case \"Harder\":\r\n                return \"Smart\";\r\n            default:\r\n                throw new IllegalArgumentException(\"Wrong player type!\");\r\n        }\r\n    }\r\n\r\n    public int getPlayerNumberInt() {\r\n        return playerNumberInt;\r\n    }\r\n\r\n    public String getFirstPlayerType() {\r\n        return firstPlayerType;\r\n    }\r\n\r\n    public String getSecondPlayerType() {\r\n        return secondPlayerType;\r\n    }\r\n\r\n    public String getThirdPlayerType() {\r\n        return thirdPlayerType;\r\n    }\r\n\r\n    public String getFourthPlayerType() {\r\n        return fourthPlayerType;\r\n    }\r\n\r\n    public int getWallNumber() {\r\n        return wallNumber;\r\n    }\r\n\r\n    private void launchGame(Stage appStage){\r\n        boolean answer = ConfirmBox.Display(\"Launch confirmation\",\r\n                \"Are you sure you want to launch the game? Be sure you selected the right settings.\");\r\n        if (answer){\r\n            // TODO implement game launch!\r\n            if (getPlayerNumberInt() == 2) {\r\n                String[] types = {getFirstPlayerType(), getSecondPlayerType()};\r\n                GameUI gameUI = new GameUI(appStage, scene, getPlayerNumberInt(), types, getWallNumber());\r\n            } else if (getPlayerNumberInt() == 4) {\r\n                String[] types = {getFirstPlayerType(), getSecondPlayerType(),\r\n                        getThirdPlayerType(), getFourthPlayerType()};\r\n                GameUI gameUI = new GameUI(appStage, scene, getPlayerNumberInt(), types, getWallNumber());\r\n            } else {\r\n                throw new IllegalArgumentException(\"expected 2 or 4 player, got \" + getPlayerNumberInt());\r\n            }\r\n        }\r\n    }\r\n}\r\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
---- src/main/java/be/ac/umons/michelsurin/gui/Menu.java	(revision 0ae0412dd83170111fc3aefe35706d32039316fe)
-+++ src/main/java/be/ac/umons/michelsurin/gui/Menu.java	(date 1588670635410)
-@@ -35,7 +35,6 @@
-     /**
-      * Save and load games.
-      */
--    private SaverLoader saverLoader;
- 
-     private ChoiceBox<String> playerNumber;
-     private ChoiceBox<String> firstAIDifficultyMenu;
-@@ -89,16 +88,15 @@
-         layout.getChildren().add(launchButton);
- 
-         loadButton = new Button("Load Game");
--        loadButton.setOnAction(new EventHandler<ActionEvent>() {
--            @Override
--            public void handle(ActionEvent event) {
-+        loadButton.setOnAction(e -> {
-+
-                 try {
--                    Game game = saverLoader.load();
-+                    Game game = SaverLoader.load();
-                     GameUI gameUI = new GameUI(window, scene, game);
--                } catch (IOException | ClassNotFoundException e) {
--                    e.printStackTrace();
-+                } catch (IOException | ClassNotFoundException f) {
-+                    f.printStackTrace();
-                 }
--            }
-+
-         });
-         layout.getChildren().add(loadButton);
- 
-Index: src/main/java/be/ac/umons/michelsurin/gui/GameUI.java
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>package be.ac.umons.michelsurin.gui;\r\n\r\nimport be.ac.umons.michelsurin.controller.Action;\r\nimport be.ac.umons.michelsurin.controller.PawnController;\r\nimport be.ac.umons.michelsurin.engine.Game;\r\nimport be.ac.umons.michelsurin.engine.Rules;\r\nimport be.ac.umons.michelsurin.engine.SaverLoader;\r\nimport be.ac.umons.michelsurin.tools.Coord;\r\nimport be.ac.umons.michelsurin.world.Board;\r\nimport javafx.animation.AnimationTimer;\r\nimport javafx.event.ActionEvent;\r\nimport javafx.event.EventHandler;\r\nimport javafx.geometry.Insets;\r\nimport javafx.geometry.Pos;\r\nimport javafx.scene.Group;\r\nimport javafx.scene.Node;\r\nimport javafx.scene.Scene;\r\nimport javafx.scene.control.Button;\r\nimport javafx.scene.effect.ColorAdjust;\r\nimport javafx.scene.effect.Glow;\r\nimport javafx.scene.effect.Shadow;\r\nimport javafx.scene.image.Image;\r\nimport javafx.scene.image.ImageView;\r\nimport javafx.scene.input.*;\r\nimport javafx.scene.layout.*;\r\nimport javafx.scene.paint.Color;\r\nimport javafx.scene.paint.Paint;\r\nimport javafx.stage.Stage;\r\n\r\nimport java.io.IOException;\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * given game settings, run a GUI game.\r\n */\r\npublic class GameUI {\r\n\r\n    /**\r\n     * Standard cell sprite\r\n     */\r\n    private final Image cellImg = new Image(\"tile.png\");\r\n    /**\r\n     * Human player sprite\r\n     */\r\n    private final Image humanPawnImg = new Image(\"neo.png\");\r\n    /**\r\n     * AI player sprite\r\n     */\r\n    private final Image AIPawnImg = new Image(\"agent.png\");\r\n    /**\r\n     * Horizontal wall sprite\r\n     */\r\n    private final Image wallHImg = new Image(\"wallH.png\");\r\n    /**\r\n     * Vertical wall sprite\r\n     */\r\n    private final Image wallVImg = new Image(\"wallV.png\");\r\n    /**\r\n     * Empty sprite used to \"hide\" the shadow wall used to give player an indication of where they will place a wall\r\n     */\r\n    private final Image empty = new Image(\"wallEmpty.png\");\r\n    /**\r\n     * Horizontal gap between cell\r\n     */\r\n    public final int Hspace = 50;\r\n    /**\r\n     * Vertical gap between cell\r\n     */\r\n    public final int Vspace = 50;\r\n    /**\r\n     * Effect that highlight the sprite attach to it. Used to show possible move for players\r\n     */\r\n    private final ColorAdjust colorCell = new ColorAdjust(0.1, 0, 0.5, 0.5);\r\n    /**\r\n     * Effect used to show a preview of the wall a player might place\r\n     */\r\n    private final Shadow wallShadow = new Shadow(1, Color.DARKRED);\r\n\r\n    /**\r\n     * The game running\r\n     */\r\n    private Game game;\r\n    /**\r\n     * Total of player in the game\r\n     */\r\n    private int playerTotal;\r\n    /**\r\n     * Array containing all the PawnController in the game\r\n     */\r\n    private PawnController[] playerArray;\r\n    /**\r\n     * The board\r\n     */\r\n    private Board board;\r\n    /**\r\n     * Size of the board\r\n     */\r\n    private int boardSize;\r\n    /**\r\n     * The pane containing all the scene\r\n     */\r\n    private BorderPane mainPane;\r\n    /**\r\n     * Group containing all the game sprite\r\n     */\r\n    private Group gameContent;\r\n    /**\r\n     * Used for the pause menu\r\n     */\r\n    private VBox pauseMenu;\r\n    /**\r\n     * Pane used for the victory screen\r\n     */\r\n    private BorderPane victoryPane;\r\n    /**\r\n     * Scene where the game takes place\r\n     */\r\n    private Scene gameScene;\r\n    /**\r\n     * Scene for the victory screen\r\n     */\r\n    private Scene victoryScene;\r\n    /**\r\n     * scene for the pause menu\r\n     */\r\n    private Scene pauseScene;\r\n    /**\r\n     * The stage of the application (the window)\r\n     */\r\n    private Stage appStage;\r\n    /**\r\n     * Save the game.\r\n     */\r\n    private Button saveButton;\r\n    /**\r\n     * Allow to return to the gameScene\r\n     */\r\n    private Button backToGameButton;\r\n    /**\r\n     * In game button used to get back to the main menu while a game is still in progress\r\n     */\r\n    private Button backToMenuInGameButton;\r\n    /**\r\n     * Button used to go back to the menu AFTER a game has been won\r\n     */\r\n    private Button backToMenu;\r\n\r\n\r\n\r\n    /**\r\n     * Save and load games.\r\n     */\r\n    private SaverLoader saverLoader = new SaverLoader();\r\n\r\n    /**\r\n     * This constructor creates a game with the settings given by the menu and display it.\r\n     * Then it will start the game with the player 0 (1st player) and given it's type, will listen for mouse event if it's\r\n     * a human else, it will get through the AnimationTimer and call the actionHandler that will play according to the\r\n     * AI type.\r\n     * @param appStage {@link #appStage}\r\n     * @param menuScene The scene containing the main menu\r\n     * @param playerNumber {@link #playerTotal}\r\n     * @param types An array of String containing the types of each player, with the first type to be associated with the first player etc...\r\n     */\r\n    public GameUI(Stage appStage, Scene menuScene, int playerNumber, String[] types, int numbOfWall){\r\n        this.appStage = appStage;\r\n\r\n        this.game = new Game(9, types, numbOfWall);\r\n        this.playerArray = game.getPlayerArray();\r\n        this.playerTotal = playerNumber;\r\n        this.board = game.getBoard();\r\n        this.boardSize = board.getSize();\r\n\r\n        this.mainPane = new BorderPane();\r\n        mainPane.setBackground(Background.EMPTY);\r\n        mainPane.setMinSize(600, 600);\r\n\r\n        this.victoryPane = new BorderPane();\r\n        victoryPane.setBackground(Background.EMPTY);\r\n        victoryPane.setMinSize(600, 600);\r\n\r\n        this.gameContent = new Group();\r\n\r\n        this.pauseMenu = new VBox();\r\n        pauseMenu.setAlignment(Pos.CENTER);\r\n        pauseMenu.setMinSize(600, 600);\r\n        pauseMenu.setBackground(Background.EMPTY);\r\n        pauseMenu.setSpacing(15);\r\n\r\n        this.gameScene = new Scene(mainPane);\r\n        this.victoryScene = new Scene(victoryPane);\r\n        this.pauseScene = new Scene(pauseMenu);\r\n\r\n        this.appStage.setScene(gameScene);\r\n\r\n        //victoryScene --------------------------------------\r\n        backToMenu = new Button(\"BACK TO THE MENUUUUUUU\");\r\n        backToMenu.setOnAction(new EventHandler<ActionEvent>() {\r\n            @Override\r\n            public void handle(ActionEvent event) {\r\n                appStage.setScene(menuScene);\r\n            }\r\n        });\r\n        victoryPane.setCenter(backToMenu);\r\n        victoryScene.getStylesheets().add(\"Viper.css\");\r\n        //pauseScene --------------------------------------\r\n        //save\r\n        saveButton = new Button(\"Save Game\");\r\n        saveButton.setBackground(Background.EMPTY);\r\n        saveButton.setTextFill(Color.GREEN);\r\n        saveButton.setOnAction(e -> {\r\n            try {\r\n                saverLoader.save(game);\r\n                System.out.println(\"I did something\");\r\n            } catch (IOException ioException) {\r\n                ioException.printStackTrace();\r\n            }\r\n        });\r\n        //back to the game\r\n        backToGameButton = new Button(\"Back to game\");\r\n        backToGameButton.setBackground(Background.EMPTY);\r\n        backToGameButton.setTextFill(Color.GREEN);\r\n        backToGameButton.setOnAction(new EventHandler<ActionEvent>() {\r\n            @Override\r\n            public void handle(ActionEvent event) {\r\n                appStage.setScene(gameScene);\r\n            }\r\n        });\r\n        //back to menu\r\n        backToMenuInGameButton = new Button(\"Back to main menu\");\r\n        backToMenuInGameButton.setBackground(Background.EMPTY);\r\n        backToMenuInGameButton.setTextFill(Color.GREEN);\r\n        backToMenuInGameButton.setOnAction(new EventHandler<ActionEvent>() {\r\n            @Override\r\n            public void handle(ActionEvent event) {\r\n                //TODO confirm box for save\r\n                appStage.setScene(menuScene);\r\n            }\r\n        });\r\n        pauseMenu.getChildren().addAll(saveButton, backToGameButton, backToMenuInGameButton);\r\n        pauseScene.getStylesheets().add(\"Viper.css\");\r\n        //gameScene --------------------------------------\r\n        mainPane.setCenter(gameContent);\r\n        gameScene.setFill(Color.BLACK);\r\n\r\n        //pauseScene access\r\n        gameScene.setOnKeyPressed(new EventHandler<KeyEvent>() {\r\n            @Override\r\n            public void handle(KeyEvent keyEvent) {\r\n                if (keyEvent.getCode().equals(KeyCode.ESCAPE)) {\r\n                    appStage.setScene(pauseScene);\r\n                }\r\n            }\r\n        });\r\n\r\n        //board drawing\r\n        for (int i = 0; i < boardSize; i++) {\r\n            for (int j = 0; j < boardSize; j++) {\r\n                ImageView cell = new ImageView();\r\n                cell.setImage(cellImg);\r\n                cell.setY(i * Vspace);\r\n                cell.setX(j * Hspace);\r\n                cell.setEffect(new Glow(0));\r\n                gameContent.getChildren().add(cell);\r\n            }\r\n        }\r\n        //pawn initialization\r\n        for (int i=0; i<playerTotal; i++) {\r\n            gameContent.getChildren().add(new ImageView());\r\n        }\r\n        //wall highlight\r\n        ImageView wallHighlight = new ImageView();\r\n        wallHighlight.setEffect(this.wallShadow);\r\n        gameContent.getChildren().add(wallHighlight);\r\n\r\n        updateWall();\r\n        updatePawn();\r\n\r\n        //TURN SYSTEM ------------------------------------------------------------------\r\n        final int[] currentPlayer = {0}; //start with player 0\r\n        final boolean[] dragActive = {false}; //used to know if a dragEvent has been triggered\r\n        final Coord[] wantedWallCoord = new Coord[1]; //used to transfer coord through events\r\n        //CLICK HANDLING\r\n        gameContent.setOnMouseClicked(new EventHandler<MouseEvent>() {\r\n            @Override\r\n            public void handle(MouseEvent event) {\r\n                Coord[] possibleCell = game.whereCanIGo(currentPlayer[0]);\r\n                Coord clickedCell = getCoordFromPos(event.getX(), event.getY());\r\n                PawnController ctrl = playerArray[currentPlayer[0]];\r\n                Coord playerCoord = ctrl.getDependency().getCoord();\r\n                int size = gameContent.getChildren().size();\r\n                ImageView lastChild = (ImageView) gameContent.getChildren().get(size-1);\r\n\r\n                if (dragActive[0] && event.getButton().compareTo(MouseButton.PRIMARY) == 0) {\r\n                    //we are left-clicking on a ghost wall, we need to place it\r\n                    resetGlowing(); //if cells are glowing the need to be reset\r\n                    if (clickedCell.compareTo(wantedWallCoord[0]) == 0) {\r\n                        //it's a click on a ghost wall, it means that we want it to be placed\r\n                        if (lastChild.getImage().equals(wallHImg)\r\n                                && Rules.canPlaceWall(playerArray, ctrl, wantedWallCoord[0], Game.directions.get(\"RIGHT\"))) {\r\n                            //Hwall\r\n                            ctrl.placeWall(clickedCell, Game.directions.get(\"RIGHT\"));\r\n                            lastChild.setImage(empty);\r\n                            updateWall();\r\n                            currentPlayer[0] = (currentPlayer[0] + 1) % playerTotal;\r\n                        } else if (lastChild.getImage().equals(wallVImg)\r\n                                && Rules.canPlaceWall(playerArray, ctrl, wantedWallCoord[0], Game.directions.get(\"UP\"))) {\r\n                            //Vwall\r\n                            ctrl.placeWall(clickedCell, Game.directions.get(\"UP\"));\r\n                            lastChild.setImage(empty);\r\n                            updateWall();\r\n                            currentPlayer[0] = (currentPlayer[0] + 1) % playerTotal;\r\n                        }\r\n                    } else {\r\n                        //click somewhere else, we reset the ghost wall\r\n                        lastChild.setImage(empty);\r\n                    }\r\n                    dragActive[0] = false; //reset the drag\r\n                } else {\r\n                    //we want to move\r\n                    if (event.getButton().compareTo(MouseButton.PRIMARY) == 0 && clickedCell.getY() < boardSize && clickedCell.getX() < boardSize\r\n                            && ctrl.getType() == \"Human\") {\r\n                        //click is on the current player\r\n                        ImageView clickedCellImage = (ImageView) gameContent.getChildren().get(clickedCell.getX() + boardSize * clickedCell.getY());\r\n                        if (playerCoord.compareTo(clickedCell) == 0) {\r\n                            //click on pawn --> we make the reachable cell glowing\r\n                            for (Coord coord : possibleCell) {\r\n                                gameContent.getChildren().get(coord.getX() + (9 * coord.getY())).setEffect(colorCell);\r\n                            }\r\n                        } else if (clickedCell.isIn(possibleCell)\r\n                                && clickedCellImage.getEffect().equals(colorCell)) {\r\n                            //if click on a glowing cell (a cell where the player can go), we mote the player to it\r\n                            int deltaY = clickedCell.getY() - playerCoord.getY();\r\n                            int deltaX = clickedCell.getX() - playerCoord.getX();\r\n                            Coord dir = new Coord(deltaY, deltaX);\r\n                            ctrl.move(dir);\r\n                            updatePawn();\r\n                            resetGlowing();\r\n                            //Check win\r\n                            if (ctrl.hasWon()) {\r\n                                appStage.setScene(victoryScene);\r\n                            } else {\r\n                                currentPlayer[0] = (currentPlayer[0] + 1) % playerTotal;\r\n                            }\r\n                        } else {\r\n                            //click is somewhere else, we reset the cell glow\r\n                            resetGlowing();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        //enter the wall highlight mode\r\n        gameContent.setOnMouseDragged(new EventHandler<MouseEvent>() {\r\n            @Override\r\n            public void handle(MouseEvent event) {\r\n                //we need a way to choose between H wall and V wall\r\n                Coord currentCellCoord = getCoordFromPos(event.getX(), event.getY());\r\n                wantedWallCoord[0] = currentCellCoord;\r\n                int size = gameContent.getChildren().size();\r\n                if (currentCellCoord.getY() < boardSize && currentCellCoord.getY() > 0 && currentCellCoord.getX() < boardSize-1\r\n                        && event.getButton().compareTo(MouseButton.SECONDARY) == 0\r\n                        && playerArray[currentPlayer[0]].getNumbWall() > 0) {\r\n                    //we are at a correct place for a wall to be placed\r\n                    //now check whether we are on top of the cell or on the bottom\r\n                    dragActive[0] = true; //tells that a drag has been triggered\r\n                    resetGlowing(); //in case we were looking for a cell\r\n                    //the following lines will determines if the mouse is on the upper or lower half of the cell\r\n                    //if upper -> Hwall, if lower -> Vwall\r\n                    if (event.getY() > currentCellCoord.getY()*(Vspace)\r\n                            && event.getY() < (currentCellCoord.getY()*(Vspace))+(Vspace/2)\r\n                            && Rules.canPlaceWall(playerArray, playerArray[currentPlayer[0]],\r\n                            currentCellCoord, Game.directions.get(\"RIGHT\"))) {\r\n                        //if we can place a Hwall, we display a ghost Hwall, waiting for click release\r\n                        ImageView wallHighlight = (ImageView) gameContent.getChildren().get(size-1);\r\n                        wallHighlight.setImage(wallHImg);\r\n                        wallHighlight.setY(currentCellCoord.getY() * Vspace - 18);\r\n                        wallHighlight.setX(currentCellCoord.getX() * Hspace - 9);\r\n                    } else if (Rules.canPlaceWall(playerArray, playerArray[currentPlayer[0]],\r\n                            currentCellCoord, Game.directions.get(\"UP\"))){\r\n                        //if we can place a Vwall, we display a ghost Vwall, waiting for click release\r\n                        ImageView wallHighlight = (ImageView) gameContent.getChildren().get(size-1);\r\n                        wallHighlight.setImage(wallVImg);\r\n                        wallHighlight.setY(currentCellCoord.getY() * Vspace - 54);\r\n                        wallHighlight.setX(currentCellCoord.getX() * Hspace + 33);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        //AI handling\r\n        new AnimationTimer() {\r\n            @Override\r\n            public void handle(long now) {\r\n                if (playerArray[currentPlayer[0]].getType() != \"Human\") {\r\n                    //current player is an AI, we call it's actionHandler\r\n                    Action.getAction(playerArray, playerArray[currentPlayer[0]]);\r\n                    updatePawn();\r\n                    updateWall();\r\n                    if (playerArray[currentPlayer[0]].hasWon()) {\r\n                        //we stop the \"loop\" and show victory screen\r\n                        this.stop();\r\n                        appStage.setScene(victoryScene);\r\n                    } else {\r\n                        //next player\r\n                        currentPlayer[0] = (currentPlayer[0] + 1) % playerTotal;\r\n                    }\r\n                }\r\n            }\r\n        }.start();\r\n        appStage.show();\r\n    }\r\n\r\n    public GameUI(Stage appStage, Scene menuScene, Game game) {\r\n        this.appStage = appStage;\r\n\r\n        this.game = game;\r\n        this.playerArray = game.getPlayerArray();\r\n        this.playerTotal = game.getPlayerArray().length;\r\n        this.board = game.getBoard();\r\n        this.boardSize = board.getSize();\r\n\r\n        this.mainPane = new BorderPane();\r\n        mainPane.setBackground(Background.EMPTY);\r\n        mainPane.setMinSize(600, 600);\r\n\r\n        this.victoryPane = new BorderPane();\r\n        victoryPane.setBackground(Background.EMPTY);\r\n        victoryPane.setMinSize(600, 600);\r\n\r\n        this.gameContent = new Group();\r\n\r\n        this.pauseMenu = new VBox();\r\n        pauseMenu.setAlignment(Pos.CENTER);\r\n        pauseMenu.setMinSize(600, 600);\r\n        pauseMenu.setBackground(Background.EMPTY);\r\n        pauseMenu.setSpacing(15);\r\n\r\n        this.gameScene = new Scene(mainPane);\r\n        this.victoryScene = new Scene(victoryPane);\r\n        this.pauseScene = new Scene(pauseMenu);\r\n\r\n        this.appStage.setScene(gameScene);\r\n\r\n        //victoryScene --------------------------------------\r\n        backToMenu = new Button(\"BACK TO THE MENUUUUUUU\");\r\n        backToMenu.setOnAction(new EventHandler<ActionEvent>() {\r\n            @Override\r\n            public void handle(ActionEvent event) {\r\n                appStage.setScene(menuScene);\r\n            }\r\n        });\r\n        victoryPane.setCenter(backToMenu);\r\n        victoryScene.getStylesheets().add(\"Viper.css\");\r\n        //pauseScene --------------------------------------\r\n        //save\r\n        saveButton = new Button(\"Save Game\");\r\n        saveButton.setBackground(Background.EMPTY);\r\n        saveButton.setTextFill(Color.GREEN);\r\n        saveButton.setOnAction(e -> {\r\n            try {\r\n                saverLoader.save(game);\r\n            } catch (IOException ioException) {\r\n                ioException.printStackTrace();\r\n            }\r\n        });\r\n        //back to the game\r\n        backToGameButton = new Button(\"Back to game\");\r\n        backToGameButton.setBackground(Background.EMPTY);\r\n        backToGameButton.setTextFill(Color.GREEN);\r\n        backToGameButton.setOnAction(new EventHandler<ActionEvent>() {\r\n            @Override\r\n            public void handle(ActionEvent event) {\r\n                appStage.setScene(gameScene);\r\n            }\r\n        });\r\n        //back to menu\r\n        backToMenuInGameButton = new Button(\"Back to main menu\");\r\n        backToMenuInGameButton.setBackground(Background.EMPTY);\r\n        backToMenuInGameButton.setTextFill(Color.GREEN);\r\n        backToMenuInGameButton.setOnAction(new EventHandler<ActionEvent>() {\r\n            @Override\r\n            public void handle(ActionEvent event) {\r\n                //TODO confirm box for save\r\n                appStage.setScene(menuScene);\r\n            }\r\n        });\r\n        pauseMenu.getChildren().addAll(saveButton, backToGameButton, backToMenuInGameButton);\r\n        pauseScene.getStylesheets().add(\"Viper.css\");\r\n        //gameScene --------------------------------------\r\n        mainPane.setCenter(gameContent);\r\n        gameScene.setFill(Color.BLACK);\r\n\r\n        //pauseScene access\r\n        gameScene.setOnKeyPressed(new EventHandler<KeyEvent>() {\r\n            @Override\r\n            public void handle(KeyEvent keyEvent) {\r\n                if (keyEvent.getCode().equals(KeyCode.ESCAPE)) {\r\n                    appStage.setScene(pauseScene);\r\n                }\r\n            }\r\n        });\r\n\r\n        //board drawing\r\n        for (int i = 0; i < boardSize; i++) {\r\n            for (int j = 0; j < boardSize; j++) {\r\n                ImageView cell = new ImageView();\r\n                cell.setImage(cellImg);\r\n                cell.setY(i * Vspace);\r\n                cell.setX(j * Hspace);\r\n                cell.setEffect(new Glow(0));\r\n                gameContent.getChildren().add(cell);\r\n            }\r\n        }\r\n        //pawn initialization\r\n        for (int i=0; i<playerTotal; i++) {\r\n            gameContent.getChildren().add(new ImageView());\r\n        }\r\n        //wall highlight\r\n        ImageView wallHighlight = new ImageView();\r\n        wallHighlight.setEffect(this.wallShadow);\r\n        gameContent.getChildren().add(wallHighlight);\r\n\r\n        updateWall();\r\n        updatePawn();\r\n\r\n        //TURN SYSTEM ------------------------------------------------------------------\r\n        final int[] currentPlayer = {0}; //start with player 0\r\n        final boolean[] dragActive = {false}; //used to know if a dragEvent has been triggered\r\n        final Coord[] wantedWallCoord = new Coord[1]; //used to transfer coord through events\r\n        //CLICK HANDLING\r\n        gameContent.setOnMouseClicked(new EventHandler<MouseEvent>() {\r\n            @Override\r\n            public void handle(MouseEvent event) {\r\n                Coord[] possibleCell = game.whereCanIGo(currentPlayer[0]);\r\n                Coord clickedCell = getCoordFromPos(event.getX(), event.getY());\r\n                PawnController ctrl = playerArray[currentPlayer[0]];\r\n                Coord playerCoord = ctrl.getDependency().getCoord();\r\n                int size = gameContent.getChildren().size();\r\n                ImageView lastChild = (ImageView) gameContent.getChildren().get(size-1);\r\n\r\n                if (dragActive[0] && event.getButton().compareTo(MouseButton.PRIMARY) == 0) {\r\n                    //we are left-clicking on a ghost wall, we need to place it\r\n                    resetGlowing(); //if cells are glowing the need to be reset\r\n                    if (clickedCell.compareTo(wantedWallCoord[0]) == 0) {\r\n                        //it's a click on a ghost wall, it means that we want it to be placed\r\n                        if (lastChild.getImage().equals(wallHImg)\r\n                                && Rules.canPlaceWall(playerArray, ctrl, wantedWallCoord[0], Game.directions.get(\"RIGHT\"))) {\r\n                            //Hwall\r\n                            ctrl.placeWall(clickedCell, Game.directions.get(\"RIGHT\"));\r\n                            lastChild.setImage(empty);\r\n                            updateWall();\r\n                            currentPlayer[0] = (currentPlayer[0] + 1) % playerTotal;\r\n                        } else if (lastChild.getImage().equals(wallVImg)\r\n                                && Rules.canPlaceWall(playerArray, ctrl, wantedWallCoord[0], Game.directions.get(\"UP\"))) {\r\n                            //Vwall\r\n                            ctrl.placeWall(clickedCell, Game.directions.get(\"UP\"));\r\n                            lastChild.setImage(empty);\r\n                            updateWall();\r\n                            currentPlayer[0] = (currentPlayer[0] + 1) % playerTotal;\r\n                        }\r\n                    } else {\r\n                        //click somewhere else, we reset the ghost wall\r\n                        lastChild.setImage(empty);\r\n                    }\r\n                    dragActive[0] = false; //reset the drag\r\n                } else {\r\n                    //we want to move\r\n                    if (event.getButton().compareTo(MouseButton.PRIMARY) == 0 && clickedCell.getY() < boardSize && clickedCell.getX() < boardSize\r\n                            && ctrl.getType() == \"Human\") {\r\n                        //click is on the current player\r\n                        ImageView clickedCellImage = (ImageView) gameContent.getChildren().get(clickedCell.getX() + boardSize * clickedCell.getY());\r\n                        if (playerCoord.compareTo(clickedCell) == 0) {\r\n                            //click on pawn --> we make the reachable cell glowing\r\n                            for (Coord coord : possibleCell) {\r\n                                gameContent.getChildren().get(coord.getX() + (9 * coord.getY())).setEffect(colorCell);\r\n                            }\r\n                        } else if (clickedCell.isIn(possibleCell)\r\n                                && clickedCellImage.getEffect().equals(colorCell)) {\r\n                            //if click on a glowing cell (a cell where the player can go), we mote the player to it\r\n                            int deltaY = clickedCell.getY() - playerCoord.getY();\r\n                            int deltaX = clickedCell.getX() - playerCoord.getX();\r\n                            Coord dir = new Coord(deltaY, deltaX);\r\n                            ctrl.move(dir);\r\n                            updatePawn();\r\n                            resetGlowing();\r\n                            //Check win\r\n                            if (ctrl.hasWon()) {\r\n                                appStage.setScene(victoryScene);\r\n                            } else {\r\n                                currentPlayer[0] = (currentPlayer[0] + 1) % playerTotal;\r\n                            }\r\n                        } else {\r\n                            //click is somewhere else, we reset the cell glow\r\n                            resetGlowing();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        //enter the wall highlight mode\r\n        gameContent.setOnMouseDragged(new EventHandler<MouseEvent>() {\r\n            @Override\r\n            public void handle(MouseEvent event) {\r\n                //we need a way to choose between H wall and V wall\r\n                Coord currentCellCoord = getCoordFromPos(event.getX(), event.getY());\r\n                wantedWallCoord[0] = currentCellCoord;\r\n                int size = gameContent.getChildren().size();\r\n                if (currentCellCoord.getY() < boardSize && currentCellCoord.getY() > 0 && currentCellCoord.getX() < boardSize-1\r\n                        && event.getButton().compareTo(MouseButton.SECONDARY) == 0\r\n                        && playerArray[currentPlayer[0]].getNumbWall() > 0) {\r\n                    //we are at a correct place for a wall to be placed\r\n                    //now check whether we are on top of the cell or on the bottom\r\n                    dragActive[0] = true; //tells that a drag has been triggered\r\n                    resetGlowing(); //in case we were looking for a cell\r\n                    //the following lines will determines if the mouse is on the upper or lower half of the cell\r\n                    //if upper -> Hwall, if lower -> Vwall\r\n                    if (event.getY() > currentCellCoord.getY()*(Vspace)\r\n                            && event.getY() < (currentCellCoord.getY()*(Vspace))+(Vspace/2)\r\n                            && Rules.canPlaceWall(playerArray, playerArray[currentPlayer[0]],\r\n                            currentCellCoord, Game.directions.get(\"RIGHT\"))) {\r\n                        //if we can place a Hwall, we display a ghost Hwall, waiting for click release\r\n                        ImageView wallHighlight = (ImageView) gameContent.getChildren().get(size-1);\r\n                        wallHighlight.setImage(wallHImg);\r\n                        wallHighlight.setY(currentCellCoord.getY() * Vspace - 18);\r\n                        wallHighlight.setX(currentCellCoord.getX() * Hspace - 9);\r\n                    } else if (Rules.canPlaceWall(playerArray, playerArray[currentPlayer[0]],\r\n                            currentCellCoord, Game.directions.get(\"UP\"))){\r\n                        //if we can place a Vwall, we display a ghost Vwall, waiting for click release\r\n                        ImageView wallHighlight = (ImageView) gameContent.getChildren().get(size-1);\r\n                        wallHighlight.setImage(wallVImg);\r\n                        wallHighlight.setY(currentCellCoord.getY() * Vspace - 54);\r\n                        wallHighlight.setX(currentCellCoord.getX() * Hspace + 33);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        //AI handling\r\n        new AnimationTimer() {\r\n            @Override\r\n            public void handle(long now) {\r\n                if (playerArray[currentPlayer[0]].getType() != \"Human\") {\r\n                    //current player is an AI, we call it's actionHandler\r\n                    Action.getAction(playerArray, playerArray[currentPlayer[0]]);\r\n                    updatePawn();\r\n                    updateWall();\r\n                    if (playerArray[currentPlayer[0]].hasWon()) {\r\n                        //we stop the \"loop\" and show victory screen\r\n                        this.stop();\r\n                        appStage.setScene(victoryScene);\r\n                    } else {\r\n                        //next player\r\n                        currentPlayer[0] = (currentPlayer[0] + 1) % playerTotal;\r\n                    }\r\n                }\r\n            }\r\n        }.start();\r\n        appStage.show();\r\n    }\r\n\r\n    /**\r\n     * will reset all the glowing effect of all cell in the board\r\n     */\r\n    private void resetGlowing() {\r\n        for (int i = 0; i < (int) Math.pow(game.getBoard().getSize(), 2); i++) {\r\n            gameContent.getChildren().get(i).setEffect(new Glow(0));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * will take each pawn sprite in the scene and update their position with their actual position\r\n     */\r\n    public void updatePawn() {\r\n        for (int i=0; i<playerTotal; i++) {\r\n            //We know that all the pawns are in this interval [boardSize, boardSize+playerTotal[\r\n            ImageView pawn = (ImageView) gameContent.getChildren().get( (boardSize*boardSize)+i );\r\n            Coord playerCoord = playerArray[i].getDependency().getCoord();\r\n            if (pawn.getImage() == null) { //if there is already an image set, it's not necessary to set it again\r\n                if (playerArray[i].getType() == \"Human\") {\r\n                    pawn.setImage(humanPawnImg); //TODO random choice between Neo/Morpheus/Trinity\r\n                } else {\r\n                    pawn.setImage(AIPawnImg);\r\n                }\r\n            }\r\n            pawn.setX(playerCoord.getX() * Hspace);\r\n            pawn.setY(playerCoord.getY() * Vspace);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * add the new wall to the display.\r\n     */\r\n    public void updateWall() {\r\n        ArrayList<Coord[]> wallList = board.getWallList();\r\n        ImageView wall = new ImageView();\r\n        for (Coord[] wallCoord : wallList) {\r\n            if (wallCoord[0].getY() == wallCoord[1].getY()) {\r\n                //horizontal wall\r\n                wall.setImage(wallHImg);\r\n                wall.setX(wallCoord[0].getX() * Hspace - 9);\r\n                wall.setY(wallCoord[0].getY() * Vspace - 18);\r\n            } else {\r\n                //vertical wall\r\n                wall.setImage(wallVImg);\r\n                wall.setX(wallCoord[0].getX() * Hspace + 33);\r\n                wall.setY(wallCoord[0].getY() * Vspace - 54);\r\n            }\r\n        }\r\n        //we add the wall at before-last index because the last index is booked for the wall highlight\r\n        gameContent.getChildren().add(gameContent.getChildren().size()-2, wall);\r\n    }\r\n\r\n    /**\r\n     * Given a position in the canvas, will return the coordinates of the sprite the position is pointing to.\r\n     * It's used to make a transition from the GUI to the game logic system.\r\n     *\r\n     * @param x\r\n     * @param y\r\n     * @return a coordinates instance for a Game object to use.\r\n     */\r\n    public Coord getCoordFromPos(double x, double y) {\r\n        int game_y = (int) y / Vspace;\r\n        int game_x = (int) x / Hspace;\r\n        return new Coord(game_y, game_x);\r\n    }\r\n\r\n    /**\r\n     * given an array of coordinates and a mouse click event. It will check if one of the coordinates corresponds\r\n     * to the click position and if one is found, it returns it.\r\n     *\r\n     * @param mouseClick the click event we are looking the position from.\r\n     * @param cellArray  the coordinates we are comparing.\r\n     * @return the corresponding coordinates. Null if iit has not been found.\r\n     */\r\n    @Deprecated\r\n    public Coord cellClickIsInArray(MouseEvent mouseClick, Coord[] cellArray) {\r\n        for (Coord coord : cellArray) {\r\n            if (getCoordFromPos(mouseClick.getX(), mouseClick.getY()).compareTo(coord) == 0) {\r\n                return coord;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n}\r\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
---- src/main/java/be/ac/umons/michelsurin/gui/GameUI.java	(revision 0ae0412dd83170111fc3aefe35706d32039316fe)
-+++ src/main/java/be/ac/umons/michelsurin/gui/GameUI.java	(date 1588670696769)
-@@ -147,10 +147,6 @@
- 
- 
- 
--    /**
--     * Save and load games.
--     */
--    private SaverLoader saverLoader = new SaverLoader();
- 
-     /**
-      * This constructor creates a game with the settings given by the menu and display it.
-@@ -210,8 +206,7 @@
-         saveButton.setTextFill(Color.GREEN);
-         saveButton.setOnAction(e -> {
-             try {
--                saverLoader.save(game);
--                System.out.println("I did something");
-+                SaverLoader.save(game);
-             } catch (IOException ioException) {
-                 ioException.printStackTrace();
-             }
-@@ -458,7 +453,7 @@
-         saveButton.setTextFill(Color.GREEN);
-         saveButton.setOnAction(e -> {
-             try {
--                saverLoader.save(game);
-+                SaverLoader.save(game);
-             } catch (IOException ioException) {
-                 ioException.printStackTrace();
-             }
-Index: src/main/java/be/ac/umons/michelsurin/engine/Save.txt
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>\u0000\u0005sr\u0000#be.ac.umons.michelsurin.engine.GameL\u0002\u0002\u0000\u0004I\u0000\fplayerNumberL\u0000\u0005boardt\u0000%Lbe/ac/umons/michelsurin/world/Board;[\u0000\tpawnArrayt\u0000%[Lbe/ac/umons/michelsurin/items/Pawn;[\u0000\u000BplayerArrayt\u00004[Lbe/ac/umons/michelsurin/controller/PawnController;xp\u0000\u0000\u0000\u0004sr\u0000#be.ac.umons.michelsurin.world.Board\u0000\t\f\u0018e9\u0002\u0000\u0004I\u0000\u0004size[\u0000\tcellArrayt\u0000&[[Lbe/ac/umons/michelsurin/world/Cell;[\u0000\tpawnCoordt\u0000&[Lbe/ac/umons/michelsurin/tools/Coord;L\u0000\bwallListt\u0000\u0015Ljava/util/ArrayList;xp\u0000\u0000\u0000\tur\u0000&[[Lbe.ac.umons.michelsurin.world.Cell;Q\"?\u0002\u0000\u0000xp\u0000\u0000\u0000\tur\u0000%[Lbe.ac.umons.michelsurin.world.Cell;\uF4EF\tk\u0002\u0000\u0000xp\u0000\u0000\u0000\tsr\u0000\"be.ac.umons.michelsurin.world.Cell\u0016t-mp\u0002\u0000\u0003Z\u0000\u0004pawnL\u0000\u0005coordt\u0000%Lbe/ac/umons/michelsurin/tools/Coord;L\u0000\nwallOnSidet\u0000\u0015Ljava/util/Hashtable;xp\u0000sr\u0000#be.ac.umons.michelsurin.tools.CoordD2\u007F\u0002\u0000\u0002I\u0000\u0001xI\u0000\u0001yxp\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000sr\u0000\u0013java.util.Hashtable\u0013\u000F%!J\u0003\u0000\u0002F\u0000\nloadFactorI\u0000\tthresholdxp?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004t\u0000\u0002UPsr\u0000\u0011java.lang.Boolean r\u0002\u0000\u0001Z\u0000\u0005valuexp\u0001t\u0000\u0004LEFTq\u0000~\u0000\u0018t\u0000\u0004DOWNsq\u0000~\u0000\u0017\u0000t\u0000\u0005RIGHTq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0000sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u0018q\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u0018q\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0003\u0000\u0000\u0000\u0000sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u0018q\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u0018xsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0004\u0000\u0000\u0000\u0000sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u0018q\u0000~\u0000\u0019q\u0000~\u0000\u0018q\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0005\u0000\u0000\u0000\u0000sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u0018q\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0006\u0000\u0000\u0000\u0000sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u0018q\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0007\u0000\u0000\u0000\u0000sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u0018q\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\b\u0000\u0000\u0000\u0000sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u0018q\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u0018xuq\u0000~\u0000\f\u0000\u0000\u0000\tsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u0018q\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0001sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u0018xsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0001sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u0018q\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0003\u0000\u0000\u0000\u0001sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u0018xsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0004\u0000\u0000\u0000\u0001sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u0018q\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0005\u0000\u0000\u0000\u0001sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u0018xsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0006\u0000\u0000\u0000\u0001sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u0018q\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0007\u0000\u0000\u0000\u0001sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\b\u0000\u0000\u0000\u0001sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u0018xuq\u0000~\u0000\f\u0000\u0000\u0000\tsq\u0000~\u0000\u000E\u0001sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0002sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u0018q\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0002sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u0018xsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0002sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u0018q\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u0018xsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0003\u0000\u0000\u0000\u0002sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u0018q\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0004\u0000\u0000\u0000\u0002sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0005\u0000\u0000\u0000\u0002sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u0018xsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0006\u0000\u0000\u0000\u0002sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u0018q\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0007\u0000\u0000\u0000\u0002sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\b\u0000\u0000\u0000\u0002sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u0018xuq\u0000~\u0000\f\u0000\u0000\u0000\tsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0003sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u0018q\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0003sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u0018xsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0003sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u0018q\u0000~\u0000\u001Aq\u0000~\u0000\u0018q\u0000~\u0000\u001Cq\u0000~\u0000\u0018xsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0003\u0000\u0000\u0000\u0003sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u0018q\u0000~\u0000\u001Aq\u0000~\u0000\u0018q\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0001sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0004\u0000\u0000\u0000\u0003sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0005\u0000\u0000\u0000\u0003sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0006\u0000\u0000\u0000\u0003sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0007\u0000\u0000\u0000\u0003sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\b\u0000\u0000\u0000\u0003sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u0018xuq\u0000~\u0000\f\u0000\u0000\u0000\tsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0004sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u0018q\u0000~\u0000\u001Aq\u0000~\u0000\u0018q\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0004sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u0018q\u0000~\u0000\u001Cq\u0000~\u0000\u0018xsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0004sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u0018q\u0000~\u0000\u0019q\u0000~\u0000\u0018q\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0003\u0000\u0000\u0000\u0004sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u0018q\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0004\u0000\u0000\u0000\u0004sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0005\u0000\u0000\u0000\u0004sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u0018xsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0006\u0000\u0000\u0000\u0004sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u0018q\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0007\u0000\u0000\u0000\u0004sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\b\u0000\u0000\u0000\u0004sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u0018xuq\u0000~\u0000\f\u0000\u0000\u0000\tsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0005sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u0018q\u0000~\u0000\u0019q\u0000~\u0000\u0018q\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0005sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u0018q\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0005sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0003\u0000\u0000\u0000\u0005sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0004\u0000\u0000\u0000\u0005sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u0018q\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0005\u0000\u0000\u0000\u0005sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u0018q\u0000~\u0000\u001Cq\u0000~\u0000\u0018xsq\u0000~\u0000\u000E\u0001sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0006\u0000\u0000\u0000\u0005sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u0018q\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0007\u0000\u0000\u0000\u0005sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\b\u0000\u0000\u0000\u0005sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u0018xuq\u0000~\u0000\f\u0000\u0000\u0000\tsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0006sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u0018q\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0006sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u0018q\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0006sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u0018q\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0003\u0000\u0000\u0000\u0006sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0004\u0000\u0000\u0000\u0006sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u0018q\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0005\u0000\u0000\u0000\u0006sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u0018q\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0006\u0000\u0000\u0000\u0006sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u0018xsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0007\u0000\u0000\u0000\u0006sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u0018q\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\b\u0000\u0000\u0000\u0006sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u0018xuq\u0000~\u0000\f\u0000\u0000\u0000\tsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0007sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u0018q\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0007sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u0018q\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0007sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u0018q\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0003\u0000\u0000\u0000\u0007sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0004\u0000\u0000\u0000\u0007sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0005\u0000\u0000\u0000\u0007sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0006\u0000\u0000\u0000\u0007sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u0018q\u0000~\u0000\u001Cq\u0000~\u0000\u0018xsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0007\u0000\u0000\u0000\u0007sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u0018q\u0000~\u0000\u001Aq\u0000~\u0000\u0018q\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\b\u0000\u0000\u0000\u0007sq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u001Bq\u0000~\u0000\u001Cq\u0000~\u0000\u0018xuq\u0000~\u0000\f\u0000\u0000\u0000\tsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0000\u0000\u0000\u0000\bsq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u0018q\u0000~\u0000\u001Aq\u0000~\u0000\u0018q\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0001\u0000\u0000\u0000\bsq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u0018q\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0002\u0000\u0000\u0000\bsq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u0018q\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0003\u0000\u0000\u0000\bsq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u0018q\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0001sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0004\u0000\u0000\u0000\bsq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u0018q\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0005\u0000\u0000\u0000\bsq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u0018q\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0006\u0000\u0000\u0000\bsq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u0018q\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u0018q\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0007\u0000\u0000\u0000\bsq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u0018q\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u0018q\u0000~\u0000\u001Cq\u0000~\u0000\u001Bxsq\u0000~\u0000\u000E\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\b\u0000\u0000\u0000\bsq\u0000~\u0000\u0014?@\u0000\u0000\u0000\u0000\u0000\bw\b\u0000\u0000\u0000\u000B\u0000\u0000\u0000\u0004q\u0000~\u0000\u0016q\u0000~\u0000\u001Bq\u0000~\u0000\u0019q\u0000~\u0000\u001Bq\u0000~\u0000\u001Aq\u0000~\u0000\u0018q\u0000~\u0000\u001Cq\u0000~\u0000\u0018xur\u0000&[Lbe.ac.umons.michelsurin.tools.Coord;QM\u001C!\u0002\u0000\u0000xp\u0000\u0000\u0000\u0004sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0004\u0000\u0000\u0000\u0003sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0004\u0000\u0000\u0000\bsq\u0000~\u0000\u0012\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0002sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0006\u0000\u0000\u0000\u0005sr\u0000\u0013java.util.ArrayListx\u001Da\u0003\u0000\u0001I\u0000\u0004sizexp\u0000\u0000\u0000\fw\u0004\u0000\u0000\u0000\fuq\u0000~\u0001\u0015\u0000\u0000\u0000\u0002sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0005\u0000\u0000\u0000\u0005sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0005\u0000\u0000\u0000\u0004uq\u0000~\u0001\u0015\u0000\u0000\u0000\u0002sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0005\u0000\u0000\u0000\u0002sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0005\u0000\u0000\u0000\u0001uq\u0000~\u0001\u0015\u0000\u0000\u0000\u0002sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0006\u0000\u0000\u0000\u0007sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0006\u0000\u0000\u0000\u0006uq\u0000~\u0001\u0015\u0000\u0000\u0000\u0002sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0004\u0000\u0000\u0000\u0006sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0005\u0000\u0000\u0000\u0006uq\u0000~\u0001\u0015\u0000\u0000\u0000\u0002sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0003\u0000\u0000\u0000\u0001sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0003\u0000\u0000\u0000\u0000uq\u0000~\u0001\u0015\u0000\u0000\u0000\u0002sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0006\u0000\u0000\u0000\bsq\u0000~\u0000\u0012\u0000\u0000\u0000\u0007\u0000\u0000\u0000\buq\u0000~\u0001\u0015\u0000\u0000\u0000\u0002sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0005sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0005uq\u0000~\u0001\u0015\u0000\u0000\u0000\u0002sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0003sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0002uq\u0000~\u0001\u0015\u0000\u0000\u0000\u0002sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0004sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0003uq\u0000~\u0001\u0015\u0000\u0000\u0000\u0002sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0002sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0001uq\u0000~\u0001\u0015\u0000\u0000\u0000\u0002sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0007sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0007uq\u0000~\u0001\u0015\u0000\u0000\u0000\u0002sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0004sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0003\u0000\u0000\u0000\u0004xur\u0000%[Lbe.ac.umons.michelsurin.items.Pawn;yu\\+\u0002\u0000\u0000xp\u0000\u0000\u0000\u0004sr\u0000\"be.ac.umons.michelsurin.items.Pawn+CY\u0002\u0000\u0003I\u0000\u0004goalZ\u0000\ngoalIsARowL\u0000\u0005startq\u0000~\u0000\u000Fxr\u0000\"be.ac.umons.michelsurin.items.MOAIv\u001AF\u0002\u0000\u0001L\u0000\u0005coordq\u0000~\u0000\u000Fxpq\u0000~\u0001\u0017\u0000\u0000\u0000\b\u0001sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0004\u0000\u0000\u0000\u0000sq\u0000~\u0001Cq\u0000~\u0001\u0018\u0000\u0000\u0000\u0000\u0001sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0004\u0000\u0000\u0000\bsq\u0000~\u0001Cq\u0000~\u0001\u0019\u0000\u0000\u0000\b\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0004sq\u0000~\u0001Cq\u0000~\u0001\u001A\u0000\u0000\u0000\u0000\u0000sq\u0000~\u0000\u0012\u0000\u0000\u0000\b\u0000\u0000\u0000\u0004ur\u00004[Lbe.ac.umons.michelsurin.controller.PawnController;!j]\u0002\u0000\u0000xp\u0000\u0000\u0000\u0004sr\u00001be.ac.umons.michelsurin.controller.PawnController,\u0001V8\u0002\u0000\u0002I\u0000\bnumbWallI\u0000\fplayerNumberxr\u0000-be.ac.umons.michelsurin.controller.Controller~yZ\u0015e]#\u0002\u0000\u0003L\u0000\u0005boardq\u0000~\u0000\u0001L\u0000\ndependencyt\u0000$Lbe/ac/umons/michelsurin/items/MOAI;L\u0000\u0004typet\u0000\u0012Ljava/lang/String;xpq\u0000~\u0000\tq\u0000~\u0001Et\u0000\u0005Human\u0000\u0000\u0000\u0007\u0000\u0000\u0000\u0000sq\u0000~\u0001Oq\u0000~\u0000\tq\u0000~\u0001Gt\u0000\u0007Debilus\u0000\u0000\u0000\u0006\u0000\u0000\u0000\u0001sq\u0000~\u0001Oq\u0000~\u0000\tq\u0000~\u0001Iq\u0000~\u0001V\u0000\u0000\u0000\u0006\u0000\u0000\u0000\u0002sq\u0000~\u0001Oq\u0000~\u0000\tq\u0000~\u0001Kq\u0000~\u0001V\u0000\u0000\u0000\t\u0000\u0000\u0000\u0003
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
---- src/main/java/be/ac/umons/michelsurin/engine/Save.txt	(revision 0ae0412dd83170111fc3aefe35706d32039316fe)
-+++ src/main/java/be/ac/umons/michelsurin/engine/Save.txt	(date 1588669895185)
-@@ -1,5 +1,7 @@
-- sr #be.ac.umons.michelsurin.engine.GameL I playerNumberL boardt %Lbe/ac/umons/michelsurin/world/Board;[ 	pawnArrayt %[Lbe/ac/umons/michelsurin/items/Pawn;[ playerArrayt 4[Lbe/ac/umons/michelsurin/controller/PawnController;xp   sr #be.ac.umons.michelsurin.world.Board 	e9 I size[ 	cellArrayt &[[Lbe/ac/umons/michelsurin/world/Cell;[ 	pawnCoordt &[Lbe/ac/umons/michelsurin/tools/Coord;L wallListt Ljava/util/ArrayList;xp   	ur &[[Lbe.ac.umons.michelsurin.world.Cell;Q"?  xp   	ur %[Lbe.ac.umons.michelsurin.world.Cell;	k  xp   	sr "be.ac.umons.michelsurin.world.Cellt-mp Z pawnL coordt %Lbe/ac/umons/michelsurin/tools/Coord;L 
-+ sr #be.ac.umons.michelsurin.engine.GameL I playerNumberL boardt %Lbe/ac/umons/michelsurin/world/Board;[ 	pawnArrayt %[Lbe/ac/umons/michelsurin/items/Pawn;[ playerArrayt 4[Lbe/ac/umons/michelsurin/controller/PawnController;xp   sr #be.ac.umons.michelsurin.world.Board 	e9 I size[ 	cellArrayt &[[Lbe/ac/umons/michelsurin/world/Cell;[ 	pawnCoordt &[Lbe/ac/umons/michelsurin/tools/Coord;L wallListt Ljava/util/ArrayList;xp   	ur &[[Lbe.ac.umons.michelsurin.world.Cell;Q"?  xp   	ur %[Lbe.ac.umons.michelsurin.world.Cell;	k  xp   	sr "be.ac.umons.michelsurin.world.Cellt-mp Z pawnL coordt %Lbe/ac/umons/michelsurin/tools/Coord;L 
- wallOnSidet Ljava/util/Hashtable;xp sr #be.ac.umons.michelsurin.tools.CoordD2 I xI yxp        sr java.util.Hashtable%!J F 
--loadFactorI 	thresholdxp?@     w      t UPsr java.lang.Boolean r Z valuexpt LEFTq ~ t DOWNsq ~  t RIGHTq ~ xsq ~  sq ~        sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~        sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~        sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~        sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~        sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~        sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~        sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~        sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xuq ~    	sq ~  sq ~        sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xuq ~    	sq ~ sq ~        sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xuq ~    	sq ~  sq ~        sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~ sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xuq ~    	sq ~  sq ~        sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xuq ~    	sq ~  sq ~        sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~ sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xuq ~    	sq ~  sq ~        sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xuq ~    	sq ~  sq ~        sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xuq ~    	sq ~  sq ~        sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~ sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xur &[Lbe.ac.umons.michelsurin.tools.Coord;QM!  xp   sq ~       sq ~       sq ~        sq ~       sr java.util.ArrayListxa I sizexp   w   uq ~   sq ~       sq ~       uq ~   sq ~       sq ~       uq ~   sq ~       sq ~       uq ~   sq ~       sq ~       uq ~   sq ~       sq ~        uq ~   sq ~       sq ~       uq ~   sq ~        sq ~       uq ~   sq ~       sq ~       uq ~   sq ~       sq ~       uq ~   sq ~       sq ~       uq ~   sq ~       sq ~       uq ~   sq ~       sq ~       xur %[Lbe.ac.umons.michelsurin.items.Pawn;yu\+  xp   sr "be.ac.umons.michelsurin.items.Pawn+CY I goalZ 
--goalIsARowL startq ~ xr "be.ac.umons.michelsurin.items.MOAIvF L coordq ~ xpq ~   sq ~        sq ~Cq ~    sq ~       sq ~Cq ~    sq ~        sq ~Cq ~     sq ~       ur 4[Lbe.ac.umons.michelsurin.controller.PawnController;!j]  xp   sr 1be.ac.umons.michelsurin.controller.PawnController,V8 I numbWallI playerNumberxr -be.ac.umons.michelsurin.controller.Controller~yZe]# L boardq ~ L 
--dependencyt $Lbe/ac/umons/michelsurin/items/MOAI;L typet Ljava/lang/String;xpq ~ 	q ~Et Human       sq ~Oq ~ 	q ~Gt Debilus      sq ~Oq ~ 	q ~Iq ~V      sq ~Oq ~ 	q ~Kq ~V   	   
-\ No newline at end of file
-+loadFactorI 	thresholdxp?@     w      t UPsr java.lang.Boolean r Z valuexpt LEFTq ~ t DOWNsq ~  t RIGHTq ~ xsq ~  sq ~        sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~        sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~        sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~        sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~        sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~        sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~        sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~        sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xuq ~    	sq ~  sq ~        sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xuq ~    	sq ~  sq ~        sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xuq ~    	sq ~  sq ~        sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xuq ~    	sq ~  sq ~        sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xuq ~    	sq ~  sq ~        sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xuq ~    	sq ~  sq ~        sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xuq ~    	sq ~  sq ~        sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xuq ~    	sq ~  sq ~        sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xsq ~  sq ~       sq ~ ?@     w      q ~ q ~ q ~ q ~ q ~ q ~ q ~ q ~ xur &[Lbe.ac.umons.michelsurin.tools.Coord;QM!  xp   sq ~        sq ~       sr java.util.ArrayListxa I sizexp    w    xur %[Lbe.ac.umons.michelsurin.items.Pawn;yu\+  xp   sr "be.ac.umons.michelsurin.items.Pawn+CY I goalZ 
-+goalIsARowL startq ~ xr "be.ac.umons.michelsurin.items.MOAIvF L coordq ~ xpq ~   q ~sq ~q ~    q ~ur 4[Lbe.ac.umons.michelsurin.controller.PawnController;!j]  xp   sr 1be.ac.umons.michelsurin.controller.PawnController,V8 I numbWallI playerNumberxr -be.ac.umons.michelsurin.controller.Controller~yZe]# L boardq ~ L 
-+dependencyt $Lbe/ac/umons/michelsurin/items/MOAI;L typet Ljava/lang/String;xpq ~ 	q ~t Human   
-+    sq ~#q ~ 	q ~ t Smarted   
-+   
-\ No newline at end of file
-Index: .gradle/buildOutputCleanup/cache.properties
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>#Mon May 04 12:25:41 CEST 2020\r\ngradle.version=6.2\r\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>windows-1252
-===================================================================
---- .gradle/buildOutputCleanup/cache.properties	(revision 0ae0412dd83170111fc3aefe35706d32039316fe)
-+++ .gradle/buildOutputCleanup/cache.properties	(date 1588669722649)
-@@ -1,2 +1,2 @@
--#Mon May 04 12:25:41 CEST 2020
--gradle.version=6.2
-+#Tue May 05 11:08:42 CEST 2020
-+gradle.version=6.3
Index: .idea/shelf/Uncommitted_changes_before_Update_at_05-05-20_11_31__Default_Changelist_.xml
===================================================================
--- .idea/shelf/Uncommitted_changes_before_Update_at_05-05-20_11_31__Default_Changelist_.xml	(revision 9d94c97cc588838438ab780d8d62f9f102db42b4)
+++ .idea/shelf/Uncommitted_changes_before_Update_at_05-05-20_11_31__Default_Changelist_.xml	(revision 9d94c97cc588838438ab780d8d62f9f102db42b4)
@@ -1,44 +0,0 @@
-<changelist name="Uncommitted_changes_before_Update_at_05-05-20_11_31_[Default_Changelist]" date="1588671094817" recycled="true" deleted="true">
-  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_05-05-20_11_31_[Default_Changelist]/shelved.patch" />
-  <option name="DESCRIPTION" value="Uncommitted changes before Update at 05-05-20 11:31 [Default Changelist]" />
-  <binary>
-    <option name="BEFORE_PATH" value="build/classes/java/main/be/ac/umons/michelsurin/gui/GameUI$3.class" />
-    <option name="AFTER_PATH" value="build/classes/java/main/be/ac/umons/michelsurin/gui/GameUI$3.class" />
-    <option name="SHELVED_PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_05-05-20_11_31_[Default_Changelist]/GameUI$3.class" />
-  </binary>
-  <binary>
-    <option name="BEFORE_PATH" value=".gradle/buildOutputCleanup/outputFiles.bin" />
-    <option name="AFTER_PATH" value=".gradle/buildOutputCleanup/outputFiles.bin" />
-    <option name="SHELVED_PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_05-05-20_11_31_[Default_Changelist]/outputFiles.bin" />
-  </binary>
-  <binary>
-    <option name="BEFORE_PATH" value="build/classes/java/main/be/ac/umons/michelsurin/gui/GameUI$4.class" />
-    <option name="AFTER_PATH" value="build/classes/java/main/be/ac/umons/michelsurin/gui/GameUI$4.class" />
-    <option name="SHELVED_PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_05-05-20_11_31_[Default_Changelist]/GameUI$4.class" />
-  </binary>
-  <binary>
-    <option name="BEFORE_PATH" value="build/classes/java/main/be/ac/umons/michelsurin/gui/Menu.class" />
-    <option name="AFTER_PATH" value="build/classes/java/main/be/ac/umons/michelsurin/gui/Menu.class" />
-    <option name="SHELVED_PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_05-05-20_11_31_[Default_Changelist]/Menu.class" />
-  </binary>
-  <binary>
-    <option name="BEFORE_PATH" value=".gradle/buildOutputCleanup/buildOutputCleanup.lock" />
-    <option name="AFTER_PATH" value=".gradle/buildOutputCleanup/buildOutputCleanup.lock" />
-    <option name="SHELVED_PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_05-05-20_11_31_[Default_Changelist]/buildOutputCleanup.lock" />
-  </binary>
-  <binary>
-    <option name="BEFORE_PATH" value="build/classes/java/main/be/ac/umons/michelsurin/gui/GameUI.class" />
-    <option name="AFTER_PATH" value="build/classes/java/main/be/ac/umons/michelsurin/gui/GameUI.class" />
-    <option name="SHELVED_PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_05-05-20_11_31_[Default_Changelist]/GameUI.class" />
-  </binary>
-  <binary>
-    <option name="BEFORE_PATH" value="build/classes/java/main/be/ac/umons/michelsurin/gui/GameUI$1.class" />
-    <option name="AFTER_PATH" value="build/classes/java/main/be/ac/umons/michelsurin/gui/GameUI$1.class" />
-    <option name="SHELVED_PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_05-05-20_11_31_[Default_Changelist]/GameUI$1.class" />
-  </binary>
-  <binary>
-    <option name="BEFORE_PATH" value="build/classes/java/main/be/ac/umons/michelsurin/gui/GameUI$2.class" />
-    <option name="AFTER_PATH" value="build/classes/java/main/be/ac/umons/michelsurin/gui/GameUI$2.class" />
-    <option name="SHELVED_PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_05-05-20_11_31_[Default_Changelist]/GameUI$2.class" />
-  </binary>
-</changelist>
\ No newline at end of file
